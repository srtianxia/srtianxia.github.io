<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
          运输层 - Srtianxia | Srtianxia&#39;s Blog
        
    </title>

    <link rel="canonical" href="http://github.com/srtianxia/srtianxia.github.io/2016/08/06/运输层/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="http://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Srtianxia&#39;s Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archives/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="http://github.com/srtianxia/srtianxia.github.io/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/home-bg.jpg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#计算机网络" title="计算机网络">计算机网络</a>
                        
                    </div>
                    <h1>运输层</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        Posted by srtianxia on
                        2016-08-06
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1 id="运输层协议概述"><a href="#运输层协议概述" class="headerlink" title="运输层协议概述"></a>运输层协议概述</h1><ul>
<li>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。</li>
<li>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。</li>
</ul>
<a id="more"></a>
<h1 id="应用进程之间的通信"><a href="#应用进程之间的通信" class="headerlink" title="应用进程之间的通信"></a>应用进程之间的通信</h1><p>在IP层看来，通信的两端是两个主机，IP数据报的首部明确的标志了这两个主机的IP地址。但是两个主机之间的通信这种说法还不够清楚，这是因为真正进行通信的实体是在主机中的<strong>进程</strong>，是两个进程之间在交换数据。从而引出了运输层，从运输层的角度看来，<strong>通信的真正端点并不是主机而是主机中的进程</strong>（端到端的通信）。</p>
<p>在一个主机中经常有多个应用进程同时分别和另一个主机的多个应用进程通信。这就表明了运输层有一个很重要的功能，<strong>复用和分用</strong>，应用层不同进程的报文通过不同的端口向下交到运输层，再往下就共用网络层提供的服务。</p>
<ul>
<li>复用指的是发送方不同的应用进程都可以使用<strong>同一个运输层协议</strong>传输数据（当然要加上适当的首部）</li>
<li>分用指的是接收方的运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程</li>
</ul>
<p>“运输层提供应用进程间的逻辑通信”。“逻辑通信”的意思是：运输层之间的通信好像是沿水平方向传送数据。但事实上这两个运输层之间并没有一条水平方向的物理连接。</p>
<h1 id="运输层的主要功能"><a href="#运输层的主要功能" class="headerlink" title="运输层的主要功能"></a>运输层的主要功能</h1><ul>
<li>运输层为应用进程之间提供端到端的逻辑通信（但网络层是为主机之间提供逻辑通信）</li>
<li>运输层还要对收到的报文进行差错检测。</li>
<li>运输层需要有两种不同的运输协议，即面向连接的 TCP 和无连接的 UDP</li>
</ul>
<h1 id="两种不同的运输协议"><a href="#两种不同的运输协议" class="headerlink" title="两种不同的运输协议"></a>两种不同的运输协议</h1><ul>
<li>运输层向高层用户<strong>屏蔽</strong>了下面网络核心的细节（如网络拓扑、所采用的路由选择协议等），它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。</li>
<li>当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工的<strong>可靠信道</strong>。</li>
<li>当运输层采用无连接的 UDP 协议时，这种逻辑通信信道是一条<strong>不可靠信道</strong>。 </li>
</ul>
<h1 id="运输层的两个主要协议"><a href="#运输层的两个主要协议" class="headerlink" title="运输层的两个主要协议"></a>运输层的两个主要协议</h1><p>TCP/IP 的运输层有两个不同的协议：</p>
<ul>
<li><strong>用户数据报协议</strong> UDP(User Datagram Protocol)</li>
<li><strong>传输控制协议</strong> TCP(Transmission Control Protocol)</li>
</ul>
<h1 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h1><ul>
<li>两个对等运输实体在通信时传送的数据单位叫作<strong>运输协议数据单元</strong>TPDU (Transport Protocol Data Unit)。</li>
<li>TCP 传送的数据单位协议是 <strong>TCP 报文段</strong>(segment)</li>
<li>UDP 传送的数据单位协议是 <strong> UDP </strong>报文或<strong>用户数据报</strong>。 </li>
</ul>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li>UDP 在传送数据之前不需要先建立连接。对方的运输层在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 是一种最有效的工作方式。</li>
<li>TCP 则提供面向连接的服务。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。  </li>
</ul>
<h2 id="还要强调两点"><a href="#还要强调两点" class="headerlink" title="还要强调两点"></a>还要强调两点</h2><ul>
<li>运输层的 UDP 用户数据报与网际层的IP数据报有很大区别。IP 数据报要经过互连网中许多路由器的存储转发，但 UDP 用户数据报是在运输层的端到端抽象的逻辑信道中传送的。</li>
<li>TCP 报文段是在运输层抽象的端到端逻辑信道中传送，这种信道是可靠的全双工信道。但这样的信道却不知道究竟经过了哪些路由器，而这些路由器也根本不知道上面的运输层是否建立了 TCP 连接。 </li>
</ul>
<h1 id="TCP-IP体系中的运输层协议"><a href="#TCP-IP体系中的运输层协议" class="headerlink" title="TCP/IP体系中的运输层协议"></a>TCP/IP体系中的运输层协议</h1><p><img src="http://upload-images.jianshu.io/upload_images/1213532-cd96192645d557da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP/IP体系中的运输层协议.png"></p>
<h1 id="运输层的端口"><a href="#运输层的端口" class="headerlink" title="运输层的端口"></a>运输层的端口</h1><ul>
<li>运行在计算机中的进程是用<strong>进程标识符</strong>来标志的。</li>
<li>运行在应用层的各种应用进程却<strong>不应当</strong>让计算机操作系统指派它的进程标识符。这是因为在因特网上使用的计算机的操作系统种类很多，而不同的操作系统又使用不同格式的进程标识符。</li>
<li>为了使运行不同操作系统的计算机的应用进程能够互相通信，就<strong>必须用统一的方法</strong>对 TCP/IP 体系的应用进程进行标志。 </li>
</ul>
<h2 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h2><ul>
<li>由于进程的创建和撤销都是<strong>动态的</strong>，发送方几乎无法识别其他机器上的进程。</li>
<li>有时我们会改换接收报文的进程，但并不需要通知所有发送方。</li>
<li>我们往往需要利用目的主机提供的功能来识别终点，而不需要知道实现这个功能的进程。</li>
</ul>
<h2 id="端口号（protocol-port-number）简称为端口（port）"><a href="#端口号（protocol-port-number）简称为端口（port）" class="headerlink" title="端口号（protocol port number）简称为端口（port）"></a>端口号（protocol port number）简称为端口（port）</h2><ul>
<li>解决这个问题的方法就是在运输层使用<strong>协议端口号</strong>(protocol port number)，或通常简称为<strong>端口</strong>(port)。</li>
<li>虽然通信的终点是应用进程，但我们可以把端口想象是通信的终点，因为我们只要把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP 来完成。</li>
</ul>
<h2 id="软件端口与硬件端口"><a href="#软件端口与硬件端口" class="headerlink" title="软件端口与硬件端口"></a>软件端口与硬件端口</h2><ul>
<li>在协议栈层间的抽象的协议端口是<strong>软件端口</strong>。</li>
<li>路由器或交换机上的端口是<strong>硬件端口</strong>。</li>
<li>硬件端口是不同硬件设备进行交互的接口，而软件端口是<strong>应用层的各种协议进程与运输实体进行层间交互的一种地址</strong>。</li>
</ul>
<h1 id="TCP的端口"><a href="#TCP的端口" class="headerlink" title="TCP的端口"></a>TCP的端口</h1><ul>
<li>端口用一个 16 位端口号进行标志（可允许有65535个不同的端口号）。</li>
<li>端口号只具有<strong>本地</strong>意义，即端口号只是为了标志本计算机应用层中的各进程。<strong>在因特网中不同计算机的相同端口号是没有联系的</strong>。</li>
</ul>
<p>由此可见两个计算机中的进程要相互通信，不仅要知道对方的IP地址，还要知道对方的端口号。</p>
<h1 id="三类端口"><a href="#三类端口" class="headerlink" title="三类端口"></a>三类端口</h1><ul>
<li>熟知端口（系统端口），数值一般为 0 -1023<br>例如： http = 80，ftp = 21</li>
<li>登记端口号，数值为1024 - 49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。</li>
<li><strong>客户端口号</strong>或<strong>短暂端口号</strong>，数值为49152 - 65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。 </li>
</ul>
<h1 id="用户数据报UDP"><a href="#用户数据报UDP" class="headerlink" title="用户数据报UDP"></a>用户数据报UDP</h1><h2 id="UDP概述"><a href="#UDP概述" class="headerlink" title="UDP概述"></a>UDP概述</h2><ul>
<li>UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即<strong>端口的功能</strong>和<strong>差错检测</strong>的功能。</li>
<li>虽然 UDP 用户数据报只能提供不可靠的交付，但 UDP 在某些方面有其特殊的优点。</li>
</ul>
<h2 id="UDP的主要特点"><a href="#UDP的主要特点" class="headerlink" title="UDP的主要特点"></a>UDP的主要特点</h2><ul>
<li>UDP 是无连接的，即发送数据之前不需要建立连接。</li>
<li>UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。</li>
<li>UDP 是面向报文的。UDP 没有拥塞控制，很适合多媒体通信的要求。<br>无拥塞控制就说明网络出现的拥塞不会使主机发送的速率降低。这对某些实时应用是很重要的（IP电话，实时视频会议等）</li>
<li>UDP 支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>UDP 的首部开销小，只有 8 个字节。 </li>
</ul>
<h2 id="面向报文的UDP"><a href="#面向报文的UDP" class="headerlink" title="面向报文的UDP"></a>面向报文的UDP</h2><ul>
<li>发送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，<strong>而是保留这些报文的边界</strong>。</li>
<li>应用层交给 UDP 多长的报文，UDP 就照样发送，即<strong>一次发送一个报文</strong>。</li>
<li>接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。</li>
<li>应用程序必须选择合适大小的报文。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-9c9383099d1ad168.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="面向报文的UDP.png"></p>
<h2 id="UDP的首部格式"><a href="#UDP的首部格式" class="headerlink" title="UDP的首部格式"></a>UDP的首部格式</h2><p><img src="http://upload-images.jianshu.io/upload_images/1213532-f5e931dd73006b13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UDP的首部格式.png"></p>
<ul>
<li><strong>源端口</strong>  在需要对方回信时选用，不需要时可全用0</li>
<li><strong>目的端口</strong></li>
<li><strong>长度</strong>  UDP用户数据报的长度，最小值为8（只由首部）</li>
<li><strong>检验和</strong>  检验UDP用户数据报在传输中是否有差错，有错就丢弃</li>
</ul>
<h2 id="UDP基于端口分用"><a href="#UDP基于端口分用" class="headerlink" title="UDP基于端口分用"></a>UDP基于端口分用</h2><p><img src="http://upload-images.jianshu.io/upload_images/1213532-6b263454f4d32480.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UDP基于端口分用.png"></p>
<h2 id="UDP差错检验"><a href="#UDP差错检验" class="headerlink" title="UDP差错检验"></a>UDP差错检验</h2><p>如果接收方UDP发现收到的报文中的目的端口号不正确（即不存在对应于该端口的号的应用进程），就丢弃该报文，并由网际控制报文协议ICMP发送<strong>端口不可达</strong>差错报文给发送方。</p>
<p>在计算检验和时，临时把<strong>“伪首部”</strong>和 UDP 用户数据报连接在一起得到一个临时的数据报，它不向下传递也不向上递交。<strong>伪首部仅仅是为了计算检验和</strong>。</p>
<p>UDP计算检验和的方法和IP数据报首部检验和方法相类似。但不同的是，IP数据报的检验和<strong>只检验IP数据报的首部</strong>，但UDP的检验和是<strong>把首部和数据部分一起检验</strong></p>
<p>计算UDP检验和的例子：<br><img src="http://upload-images.jianshu.io/upload_images/1213532-e63f685cb8687e29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UDP检验和的例子.png"></p>
<p>在发送方，先把全0放入检验和字段，再把伪首部以及UDP用户数据报看成是许多16位的字串接起来。若UDP用户报的数据部分不是偶数个字节，则要填入一个全零字节（先不发送）。然后按照<strong>二进制反码</strong>计算出这些16位字的和。将此和的二进制反码写入<strong>检验和字段</strong>后，就发送这样的UDP数据报。在接收方，把收到的UDP数据报连通伪首部（以及可能填充全零字节）一起，按二进制反码求这些16位字的和。当无差错时其结果应为全1（原本的检验和为0，封装成数据报后再次相加的时候就多个检验和反码相加，所以无差错时结果为1）。</p>
<h1 id="传输控制协议TCP概述"><a href="#传输控制协议TCP概述" class="headerlink" title="传输控制协议TCP概述"></a>传输控制协议TCP概述</h1><h2 id="TCP最主要的特点"><a href="#TCP最主要的特点" class="headerlink" title="TCP最主要的特点"></a>TCP最主要的特点</h2><ul>
<li>TCP 是<strong>面向连接</strong>的运输层协议<br>建立与释放连接</li>
<li>每一条 TCP 连接只能有两个<strong>端点</strong>(endpoint)，每一条 TCP 连接只能是<strong>点对点的（一对一）</strong></li>
<li>TCP 提供<strong>可靠交付</strong>的服务。<br>无差错、不重复、不丢失、并且按序到达</li>
<li>TCP 提供<strong>全双工</strong>通信<br>TCP在两端设置了发送和接收缓存</li>
<li>面向<strong>字节流</strong><br>这里的<strong>流</strong>指的是<strong>流入到进程或从进程流出的字节序列</strong>，面向字节流的含义是：虽然应用程序和TCP的交互是一次一个数据块（<strong>大小不等</strong>），但TCP把应用程序交下来的数据看成仅仅是一连串的<strong>无结构的字节流</strong>。TCP并不知道所传输的字节流的含义。TCP并不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应的大小关系（发送发交给发送方TCP10个数据块，但接收方的TPC用了4个数据块就把收到的字节流交付上层的应用程序）。但接收方应用程序收到的字节流必须和发送方应用程序发送的字节流完全一样。</li>
</ul>
<h2 id="TCP面向流的概念"><a href="#TCP面向流的概念" class="headerlink" title="TCP面向流的概念"></a>TCP面向流的概念</h2><p><img src="http://upload-images.jianshu.io/upload_images/1213532-7e426d18aaf9dba4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP面向流的概念.png"></p>
<h2 id="应当注意"><a href="#应当注意" class="headerlink" title="应当注意"></a>应当注意</h2><ul>
<li>TCP 连接是一条<strong>虚连接</strong>而不是一条真正的物理连接。</li>
<li>TCP 对应用进程一次把多长的报文发送到TCP 的缓存中是不关心的。</li>
<li>TCP 根据对方给出的窗口值和当前<strong>网络拥塞的程度</strong>来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。</li>
<li>TCP 可把太长的数据块划分短一些再传送。TCP 也可等待积累有足够多的字节后再构成报文段发送出去。 </li>
</ul>
<h2 id="TCP的连接"><a href="#TCP的连接" class="headerlink" title="TCP的连接"></a>TCP的连接</h2><ul>
<li>TCP 把连接作为最基本的抽象</li>
<li>每一条 TCP 连接有两个端点</li>
<li>TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做<strong>套接字(socket)</strong>或<strong>插口</strong></li>
<li>端口号<strong>拼接到</strong>(contatenated with) IP 地址即构成了套接字</li>
</ul>
<h3 id="套接字（socket）"><a href="#套接字（socket）" class="headerlink" title="套接字（socket）"></a>套接字（socket）</h3><p><img src="http://upload-images.jianshu.io/upload_images/1213532-21d721e0f1569638.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="套接字.png"></p>
<p><strong>每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定，即：</strong><br><img src="http://upload-images.jianshu.io/upload_images/1213532-f446e64ec3854343.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP连接.png"></p>
<h3 id="同一个名词socket有多种不同的意思"><a href="#同一个名词socket有多种不同的意思" class="headerlink" title="同一个名词socket有多种不同的意思"></a>同一个名词socket有多种不同的意思</h3><ul>
<li>应用编程接口 API 称为 socket API, 简称为 socket。</li>
<li>socket API 中使用的一个函数名也叫作 socket。</li>
<li>调用 socket 函数的端点称为 socket。</li>
<li>调用 socket 函数时其返回值称为 socket 描述符，可简称为 socket。</li>
<li>在操作系统内核中连网协议的 Berkeley 实现，称为 socket 实现。    </li>
</ul>
<h1 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h1><p>TCP发送的报文段是交给IP层传输的。但IP层只提供尽最大努力服务，也就是说，TCP下面的网络所提供的是不可靠传输，因此，TCP必须采用适当的措施才能使得两个运输层之间的通信变得可靠。</p>
<h2 id="可靠传输有以下两个特点"><a href="#可靠传输有以下两个特点" class="headerlink" title="可靠传输有以下两个特点"></a>可靠传输有以下两个特点</h2><ul>
<li>传输信道不产生差错</li>
<li>不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据</li>
</ul>
<p>在这样的理想传输条件下，不需要采取任何措施就能够实现可靠传输。然而实际的网络都不具备以上两个理想的条件。但我们可以使用一些可靠传输协议，当出现差错时让发送方重传出现差错的数据，同时在接收方来不及处理收到的数据时，及时告诉发送方适当的降低发送数据的速度，这样一来，本来是不可靠的传输信道就能够实现可靠传输。</p>
<h2 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h2><p><img src="http://upload-images.jianshu.io/upload_images/1213532-1128e8bb590663ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="停止等待协议.png"></p>
<ul>
<li>在发送完一个分组后，必须暂时保留已发送的分组的副本<br>为发生超时重传而使用，只有收到相应的确认报文时才能清除暂时保存的副本</li>
<li>分组和确认分组都必须进行编号<br>这样才能明确是哪一个发送出去的分组收到了确认，而哪一个分组还没收到确认</li>
<li>超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些</li>
</ul>
<h3 id="确认丢失和确认迟到"><a href="#确认丢失和确认迟到" class="headerlink" title="确认丢失和确认迟到"></a>确认丢失和确认迟到</h3><p><img src="http://upload-images.jianshu.io/upload_images/1213532-6499497f7b5ed119.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="确认丢失和确认迟到.png"></p>
<h2 id="可靠通信的实现"><a href="#可靠通信的实现" class="headerlink" title="可靠通信的实现"></a>可靠通信的实现</h2><ul>
<li>使用上述的确认和重传机制，我们就可以<strong>在不可靠的传输网络上实现可靠的通信</strong></li>
<li>这种可靠传输协议常称为<strong>自动重传请求ARQ</strong> (Automatic Repeat reQuest)</li>
<li>ARQ 表明重传的请求是<strong>自动</strong>进行的。接收方不需要请求发送方重传某个出错的分组 </li>
</ul>
<h2 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h2><p>停止等待协议的优点是简单，但缺点是<strong>信道利用率</strong>太低。</p>
<p>假定AB之间有一条直通的信道来传送分组<br><img src="http://upload-images.jianshu.io/upload_images/1213532-e50ef8ad5f5e15b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="信道利用率.png"></p>
<p>这里的TD是A发送分组所需要的时间（显然TD = 分组长度 / 数据速率）再假定TA是B发送确认分组所需要的时间（A和B处理分组的时间都忽略不计）那么A在经过TD+RTT+TA时间后才能发送下一个分组，这里的RTT是往返时间，因为只有TD是采用来传输有用的数据（这个数据包括了分组首部，如果可以知道传输更精确的数据的时间，可以计算的更精确），所有信道利用率为<br><img src="http://upload-images.jianshu.io/upload_images/1213532-e464b7bcb4b015c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="信道利用率公式.png"></p>
<p>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用<strong>流水线传输</strong>：就是发送方可以<strong>连续的发送多个分组</strong>，不必每发完一个分组就停下来等待对方的确认。这样可使信道上一直有数据不间断地在传送。显然这种传输方式可以获得很高的信道利用率</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-6cf1a16069a58da5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流水线传输.png"></p>
<p>当时使用流水线传输时，就要使用下面介绍的<strong>连续ARQ协议</strong>和<strong>滑动窗口协议</strong></p>
<h2 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h2><p>滑动窗口协议比较复杂，是TCP协议的精髓所在，在这里先给出ARQ协议最基本的概念，但不涉及到许多细节问题。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-f89a613448411313.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="连续ARQ协议.png"><br>位于发送窗口的分组都可以连续的发送出去，而不需要等待对方的确认，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。</p>
<p><strong>详细可以见P201</strong></p>
<h3 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h3><ul>
<li>接收方一般采用<strong>累积确认</strong>的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：<strong>到这个分组为止的所有分组都已正确收到了</strong>。</li>
<li>累积确认有的优点是：容易实现，即使确认丢失也不必重传。缺点是：不能向发送方反映出接收方已经正确收到的所有分组的信息。</li>
</ul>
<h3 id="Go-back-N（回退N）"><a href="#Go-back-N（回退N）" class="headerlink" title="Go - back - N（回退N）"></a>Go - back - N（回退N）</h3><ul>
<li>如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。</li>
<li>这就叫做 Go-back-N（回退 N），表示需要再退回来重传已发送过的 N 个分组。</li>
<li>可见当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。 </li>
</ul>
<h3 id="TCP可靠通信的具体实现"><a href="#TCP可靠通信的具体实现" class="headerlink" title="TCP可靠通信的具体实现"></a>TCP可靠通信的具体实现</h3><ul>
<li>TCP 连接的<strong>每一端</strong>都必须设有两个窗口——一个<strong>发送窗口</strong>和一个<strong>接收窗口</strong>。</li>
<li>TCP 的可靠传输机制用<strong>字节的序号</strong>进行控制。TCP 所有的确认都是<strong>基于序号</strong>而不是基于报文段。</li>
<li>TCP 两端的四个窗口经常处于<strong>动态变化</strong>之中。<br>TCP连接的往返时间 RTT 也<strong>不是固定不变的</strong>。需要使用特定的算法估算较为合理的重传时间。  </li>
</ul>
<h1 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h1><p>TCP虽然是面向字节流的，但是TCP传送的数据单元却是报文段（可以看上述TCP面向流的概念），而且TCP的<strong>全部功能都体现在它的首部中各个字段</strong>。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-2c7b771a99673ccf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP报文段的首部格式.png"></p>
<ul>
<li><strong>源端口和目的端口字段</strong>——各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。  </li>
<li><strong>序号字段</strong>——占 4 字节。TCP 连接中传送的数据流中的<strong>每一个字节都编上一个序号</strong>。序号字段的值则指的是本报文段所发送的数据的<strong>第一个字节的序号</strong>。（如果不理解，可以看P202）</li>
<li><strong>确认号字段</strong>——占 4 字节，是<strong>期望收到对方的下一个报文段的数据的第一个字节的序号</strong>。例如，B正确收到了A发送过来的一个报文段，其序号字段值是501，而数据长度是200字节（序号501 - 700），这表明B正确收到了A发送的到序号700为止的数据，因此，B期望收到A的下一个数据序号为701，于是B在发送给A的确认报文段中把确认号置位701。<strong>总之，若确认号为N，则表明到N-1为止的所有数据都已正确收到</strong>。</li>
<li><strong>数据偏移（即首部长度）</strong>——占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）。  </li>
<li><strong>保留字段</strong>——占 6 位，保留为今后使用，但目前应置为 0</li>
<li><strong>紧急 URG</strong> —— 当 URG  =  1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)</li>
<li><strong>确认 ACK</strong> —— 只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。TCP规定，在建立连接后所有传送的报文段都必须把ACK置1</li>
<li><strong>推送 PSH (PuSH)</strong> —— 接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。 </li>
<li><strong>复位 RST (ReSeT)</strong> —— 当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。</li>
<li><strong>同步 SYN</strong> —— 在连接建立时用来同步序号，当SYN = 1而ACK = 0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应的报文段中使SYN = 1和ACK = 1。所以，SYN = 1 表示这是一个<strong>连接请求或连接接受报文</strong>。</li>
<li><strong>终止 FIN (FINis)</strong> —— 用来释放一个连接。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 </li>
<li><strong>窗口字段</strong> —— 占 2 字节，窗口值是[0,2^16 -1]之间的整数。窗口指的是发送本报文段的一方的<strong>接收窗口</strong>（而不是自己的发送窗口）。窗口值<strong>告诉对方</strong>：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之<strong>窗口值作为接收方让发送方设置其发送窗口的依据。</strong>例如。设确认号是701，窗口字段是1000.这就表明，从701号算起，发送此报文段的一方还有接收1000个字节数据（字节序号701-1700）的接收缓存空间。<strong>总之，窗口字段指出了现在允许对方发送的数据量。窗口值是经常在动态变化着</strong></li>
<li><strong>检验和</strong> —— 占 2 字节。检验和字段检验的范围包括首部和数据这两部分。<strong>与UDP一样</strong>在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。<strong>不同点可以见P204</strong></li>
<li><strong>紧急指针字段</strong> —— 占 16 位，仅在URG = 1时才有意义，它指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面，因此紧急指针指出了紧急数据的末尾在报文段中的位置）。  </li>
<li><strong>选项字段</strong> —— 长度可变。TCP 最初只规定了一种选项，即<strong>最大报文段长度 MSS</strong>。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。” <strong>MSS (Maximum Segment Size)是 TCP 报文段中的数据字段的最大长度。数据字段加上 TCP 首部才等于整个的 TCP 报文段。</strong></li>
<li><strong>其他选项</strong> <ul>
<li>窗口扩大选项 ——占 3 字节，其中有一个字节表示移位值 S。新的窗口值等于TCP 首部中的窗口位数增大到(16 + S)，相当于把窗口值向左移动 S 位后获得实际的窗口大小。</li>
<li>时间戳选项——占10 字节，其中最主要的字段时间戳值字段（4 字节）和时间戳回送回答字段（4 字节）。</li>
<li>选择确认选项<br><strong>选项详解请见P205</strong></li>
</ul>
</li>
<li>填充字段 —— 这是为了使整个首部长度是<strong> 4 字节</strong>的整数倍。 </li>
</ul>
<h1 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h1><h2 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h2><p><strong>详解请见P206，注意图中的后沿，前沿</strong><br><img src="http://upload-images.jianshu.io/upload_images/1213532-be32f8ec668c6ebe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="以字节为单位的滑动窗口01.png"></p>
<p><strong>从下图可以看出来，要描述一个发送窗口的状态需要三个指针：P1，P2，P3</strong><br><img src="http://upload-images.jianshu.io/upload_images/1213532-01496417e5f10eb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="以字节为单位的滑动窗口02.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-32762956e1c7c819.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="以字节为单位的滑动窗口03.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-374b10eabc809655.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="以字节为单位的滑动窗口04.png"></p>
<p><strong>有很多信息见P208，这里不赘述</strong></p>
<h3 id="发送-接收缓存"><a href="#发送-接收缓存" class="headerlink" title="发送/接收缓存"></a>发送/接收缓存</h3><p>发送方的应用进程把字节流写入TCP的发送缓存，接收方的应用进程从TCP的接收缓存中读取字节流。下面进一步讨论前面讲的<strong>窗口和缓存</strong>的关系</p>
<p><strong>发送缓存</strong><br><img src="http://upload-images.jianshu.io/upload_images/1213532-ae643d5b8c73e8a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="发送缓存.png"><br><strong>接收缓存</strong><br><img src="http://upload-images.jianshu.io/upload_images/1213532-2d7cb971f8fa6cb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="接收缓存.png"></p>
<h4 id="发送与接收缓存的作用"><a href="#发送与接收缓存的作用" class="headerlink" title="发送与接收缓存的作用"></a>发送与接收缓存的作用</h4><ul>
<li>发送缓存用来暂时存放：<ul>
<li>发送应用程序传送给发送方 TCP 准备发送的数据；</li>
<li>TCP 已发送出但尚未收到确认的数据。</li>
</ul>
</li>
</ul>
<p>发送窗口通常只是发送缓存的一部分，已被确认的数据应当从发送缓存中删除，因此<strong>发送缓存和发送窗口的后沿是重合</strong>的。发送应用程序最后写入发送缓存的字节减去最后被确认的字节，就是还保留在发送缓存中被写入的字节。发送应用程序必须控制写入缓存的速率，不能太快 ，否则发送缓存就会没有存放数据的空间。</p>
<ul>
<li>接收缓存用来暂时存放：<ul>
<li>按序到达的、但尚未被接收应用程序读取的数据；</li>
<li>不按序到达的数据。 </li>
</ul>
</li>
</ul>
<p>如果收到的分组被检测出有差错，则要丢弃。如果接收应用程序来不及读取收到的数据，接收缓存最终就会被填满，使接收窗口减少到零。反之，如果接收应用程序能够及时从接收缓存中读取收到的数据，接收窗口就可以增大，但最大不能超过接收缓存的大小。</p>
<h5 id="需要强调三点"><a href="#需要强调三点" class="headerlink" title="需要强调三点"></a>需要强调三点</h5><ul>
<li>A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）。</li>
<li>TCP 标准没有规定对不按序到达的数据应如何处理。通常是<strong>先临时存放在接收窗口</strong>中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。</li>
<li>TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。  </li>
</ul>
<h2 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h2><ul>
<li>重传机制是 TCP 中最重要和最复杂的问题之一。</li>
<li>TCP <strong>每发送</strong>一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。</li>
</ul>
<h3 id="往返时延的方差很大"><a href="#往返时延的方差很大" class="headerlink" title="往返时延的方差很大"></a>往返时延的方差很大</h3><ul>
<li>由于 TCP 的下层是一个互联网环境，IP 数据报所选择的路由变化很大。因而运输层的往返时间的方差也很大。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-5473c7cad2f538b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="往返时延的方差很大.png"></p>
<h3 id="加权平均往返时间RTT"><a href="#加权平均往返时间RTT" class="headerlink" title="加权平均往返时间RTT"></a>加权平均往返时间RTT</h3><p>TCP才用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间RTT。</p>
<p>TCP 保留了 RTT 的一个<strong>加权平均往返时间 RTTs</strong>（这又称为平滑（smooth）的往返时间，因为是加权平均，所以是平滑的）。<br>第一次测量到 RTT 样本时，<strong>RTTS 值就取为所测量到的 RTT 样本值</strong>。以后每测量到一个新的 RTT 样本，就按下式重新计算一次 RTTS：<br><img src="http://upload-images.jianshu.io/upload_images/1213532-0a4260e3f82b4ba8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="加权平均公式.png"><br>式中，0=&lt;a&lt;1。若 a 很接近于零，表示 RTT 值更新较慢(新的RTTs值和旧的RTTs值相比变化不大)。若选择 a 接近于 1，则表示 RTT 值更新较快(新的RTTs值受新的RTT样本的影响较大)。<br>RFC 2988 推荐的 a 值为 1/8，即 0.125。 </p>
<h3 id="超时重传时间RTO"><a href="#超时重传时间RTO" class="headerlink" title="超时重传时间RTO"></a>超时重传时间RTO</h3><p>显然，RTO 应略大于上面得出的加权平均往返时间 RTTs<br>RFC 2988 建议使用下式计算 RTO：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-2139de0e520393c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RTO.png"></p>
<p>RTTD 是 RTT 的<strong>偏差的</strong>加权平均值，他与RTTs和新的RTT样本之差有关。<br>RFC 2988 建议这样计算 RTTD。第一次测量时，RTTD 值取为测量到的 RTT 样本值的一半。在以后的测量中，则使用下式计算加权平均的 RTTD：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-1e55d27f1aab1e17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RTTD .png"></p>
<p>β是个小于 1 的系数，其推荐值是 1/4，即 0.25。</p>
<h3 id="往返时间的测量相当复杂"><a href="#往返时间的测量相当复杂" class="headerlink" title="往返时间的测量相当复杂"></a>往返时间的测量相当复杂</h3><ul>
<li>TCP 报文段 1 没有收到确认。重传（即报文段 2）后，收到了确认报文段 ACK。</li>
<li>如何判定此确认报文段是对原来的报文段 1 的确认，还是对重传的报文段 2 的确认？ </li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-cb97aca9c099ae05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="往返时间的测量相当复杂.png"></p>
<h3 id="Karn算法"><a href="#Karn算法" class="headerlink" title="Karn算法"></a>Karn算法</h3><p>为了解决上面那个问题，Karn提出了一个算法</p>
<p>在计算平均往返时间 RTT 时，只要<strong>报文段重传了，就不采用其往返时间样本。这样得出的加权平均平均往返时间 RTTS 和超时重传时间 RTO 就较准确。 </strong></p>
<p>但是，这又有了新的问题、设想出现这样的情况：报文段的时延突然增大了很多。因此在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据Karn算法，不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新。</p>
<h3 id="修正的Karn算法"><a href="#修正的Karn算法" class="headerlink" title="修正的Karn算法"></a>修正的Karn算法</h3><p>报文段每重传一次，就把 RTO 增大一些：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-83c33aff22e7a7dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修正的Karn算法.png"></p>
<p>系数 γ 的典型值是 2 。<br>当不再发生报文段的重传时，才根据报文段的往返时延更新平均往返时延 RTT 和超时重传时间 RTO 的数值。<br>实践证明，这种策略较为合理。 </p>
<h2 id="选择确认SACK（selective-ACK）"><a href="#选择确认SACK（selective-ACK）" class="headerlink" title="选择确认SACK（selective ACK）"></a>选择确认SACK（selective ACK）</h2><p>接收方收到了和前面的字节流<em>不连续*</em>的两个字节块（只是未按序号，它是无差错的）</p>
<p>如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据。 </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-6d4330c56e5dfe70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="接收到不连续的字节流.png"></p>
<p>和前后字节不连续的每一个字节块都有两个边界：左边界和右边界。图中用四个指针标记这些边界。第一个字节块的左边界 L1 = 1501，但右边界 R1 = 3001。左边界指出字节块的第一个字节的序号，但右边界减 1 才是字节块中的最后一个序号。第二个字节块的左边界 L2 = 3501，而右边界 R2 = 4501。 </p>
<h3 id="RFC-2018的规定"><a href="#RFC-2018的规定" class="headerlink" title="RFC 2018的规定"></a>RFC 2018的规定</h3><ul>
<li>TCP首部并没有哪个字段能提供上述这些字节块的边界信息。如果要使用选择确认，那么在建立 TCP 连接时，就要在 TCP 首部的选项中加上“允许 SACK”的选项，而双方必须都事先商定好。</li>
<li>如果使用选择确认，那么原来首部中的“确认号字段”的用法仍然不变。只是以后在 TCP 报文段的首部中都增加了 SACK 选项，以便报告收到的不连续的字节块的边界。</li>
<li>由于首部选项的长度最多只有 40 字节，而指明一个边界就要用掉 4 字节，因此在选项中最多只能指明 4 个字节块的边界信息。</li>
</ul>
<p><strong>详见P211</strong></p>
<h1 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h1><h2 id="利用滑动窗口实现流量控制"><a href="#利用滑动窗口实现流量控制" class="headerlink" title="利用滑动窗口实现流量控制"></a>利用滑动窗口实现流量控制</h2><p>一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，<br>接收方就可能来不及接收，这就会造成数据的丢失。</p>
<p><strong>流量控制(flow control)就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞</strong>。</p>
<p>利用<strong>滑动窗口机制</strong>可以很方便地在 TCP 连接上实现流量控制。 </p>
<h2 id="流量控制举例"><a href="#流量控制举例" class="headerlink" title="流量控制举例"></a>流量控制举例</h2><p>A 向 B 发送数据。在连接建立时，B 告诉 A：“我的接收窗口 rwnd = 400（字节）”。<strong>看下TCP首部窗口字段的用处</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-8b5b080e58639bda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流量控制举例.png"></p>
<p>接收方的主机B一共进行了3次流量控制（蓝线）</p>
<p>考虑一种情况，B向A发送了零窗口的报文段后不久，B的接收缓存又有了一些存储空间。于是B向A发送了rwnd = 400的报文段，然而这个报文段在传输过程中丢失了。A一直等收到B发送非零窗口的通知，B也一直等A发送数据来，就形成了<strong>死锁</strong>。下面的<strong>持续计时器</strong>就是为了打破死锁僵局的</p>
<h2 id="持续计时器（persistence-timer）"><a href="#持续计时器（persistence-timer）" class="headerlink" title="持续计时器（persistence timer）"></a>持续计时器（persistence timer）</h2><ul>
<li>TCP 为每一个连接设有一个<strong>持续计时器</strong></li>
<li>只要 TCP 连接的一方收到对方的<strong>零窗口通知</strong>，就启动持续计时器。</li>
<li>若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。</li>
<li>若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。</li>
<li>若窗口不是零，则<strong>死锁</strong>的僵局就可以打破了。 </li>
</ul>
<h2 id="必须考虑传输效率"><a href="#必须考虑传输效率" class="headerlink" title="必须考虑传输效率"></a>必须考虑传输效率</h2><p>应用进程把数据传送到TCP发送缓存后，剩下的发送任务就由TCP来控制了。可以用不同的机制来控制 TCP 报文段的发送时机:</p>
<ul>
<li>第一种机制是 TCP 维持一个变量，它等于<strong>最大报文段长度 MSS</strong>。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。</li>
<li>第二种机制是由发送方的应用进程指明要求发送报文段，即 TCP 支持的<strong>推送(push)操作</strong>。</li>
<li>第三种机制是发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去。</li>
</ul>
<p><strong>至于如何控制发送的 时机 详见P213</strong></p>
<h1 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h1><h2 id="拥塞控制的一般原理"><a href="#拥塞控制的一般原理" class="headerlink" title="拥塞控制的一般原理"></a>拥塞控制的一般原理</h2><p>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏——产生<strong>拥塞(congestion)</strong></p>
<p>出现资源拥塞的条件： 对资源需求的<strong>总和</strong> &gt; 可用资源      </p>
<p>若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。  </p>
<p>解决拥塞的要点是<strong>平衡</strong>，要让整个系统的性能想匹配（P214）。</p>
<h2 id="拥塞控制与流量控制关系密切"><a href="#拥塞控制与流量控制关系密切" class="headerlink" title="拥塞控制与流量控制关系密切"></a>拥塞控制与流量控制关系密切</h2><ul>
<li><strong>拥塞控制</strong>所要做的都有一个前提，就是<strong>网络能够承受现有的网络负荷</strong>。</li>
<li>拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。 </li>
<li><strong>流量控制</strong>往往指在给定的<strong>发送端和接收端</strong>之间的<strong>点对点</strong>通信量的控制。 </li>
<li>流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>
</ul>
<h2 id="拥塞控制所起的作用"><a href="#拥塞控制所起的作用" class="headerlink" title="拥塞控制所起的作用"></a>拥塞控制所起的作用</h2><p>横坐标为<strong>提供的负载</strong>，代表单位时间内输入给网络的分组的数目（也叫作输入负载或网络负载），纵坐标是<strong>吞吐量</strong>，代表单位时间内从网络输出的分组数目。<br><img src="http://upload-images.jianshu.io/upload_images/1213532-c7c75a718f2d510e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拥塞控制所起的作用.png"></p>
<h2 id="拥塞控制的一般原理-1"><a href="#拥塞控制的一般原理-1" class="headerlink" title="拥塞控制的一般原理"></a>拥塞控制的一般原理</h2><ul>
<li>拥塞控制是很难设计的，因为它是一个动态的（而不是静态的）问题。</li>
<li>当前网络正朝着高速化的方向发展，这很容易出现缓存不够大而造成分组的丢失。但分组的丢失是网络发生拥塞的<strong>征兆</strong>而不是<strong>原因</strong>。</li>
<li>在许多情况下，甚至正是拥塞控制本身成为引起网络性能恶化甚至发生死锁的原因。这点应特别引起重视。 </li>
</ul>
<h2 id="开环和闭环控制"><a href="#开环和闭环控制" class="headerlink" title="开环和闭环控制"></a>开环和闭环控制</h2><ul>
<li>开环控制方法就是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞，但是系统运行起来就不再中途更正了。 </li>
<li>闭环控制是基于反馈环路的概念。属于闭环控制的有以下几种措施： <ul>
<li>监测网络系统以便检测到拥塞在何时、何处发生。</li>
<li>将拥塞发生的信息传送到可采取行动的地方。</li>
<li>调整网络系统的运行以解决出现的问题。</li>
</ul>
</li>
</ul>
<h2 id="检测拥塞的指标"><a href="#检测拥塞的指标" class="headerlink" title="检测拥塞的指标"></a>检测拥塞的指标</h2><p>由于缺少缓存空间而被丢弃的分组的百分数，平均队列长度，超时重传的分组数，平均分组时延，分组时延的标准差等，这些指标的上升都标志着拥塞的增长。</p>
<h2 id="几种拥塞控制方法"><a href="#几种拥塞控制方法" class="headerlink" title="几种拥塞控制方法"></a>几种拥塞控制方法</h2><h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><ul>
<li>发送方维持一个叫做<strong>拥塞窗口</strong> cwnd (congestion window)的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。<strong>发送方让自己的发送窗口等于拥塞窗口</strong>。如再考虑到接收方的接收能力，则发送窗口还可能小于拥塞窗口。</li>
<li>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。 </li>
</ul>
<h4 id="慢开始算法的原理"><a href="#慢开始算法的原理" class="headerlink" title="慢开始算法的原理"></a>慢开始算法的原理</h4><p>方便起见，我们用<strong>报文段的个数</strong>作为窗口大小的单位</p>
<ul>
<li>在主机刚刚开始发送报文段时可先设置拥塞窗口 cwnd = 1，即设置为一个最大报文段 MSS 的数值。</li>
<li>在每收到一个对新的报文段的确认后，将拥塞窗口加 1，即增加一个 MSS 的数值。</li>
<li>用这样的方法逐步增大发送端的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。 </li>
</ul>
<h4 id="传播轮次（transmission-round）"><a href="#传播轮次（transmission-round）" class="headerlink" title="传播轮次（transmission round）"></a>传播轮次（transmission round）</h4><ul>
<li>使用慢开始算法后，每经过一个<strong>传输轮次</strong>，<strong>拥塞窗口 cwnd 就加倍</strong>。 </li>
<li>一个传输轮次所经历的时间其实就是往返时间 RTT。</li>
<li>“传输轮次”更加强调：把拥塞窗口 cwnd 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。</li>
<li>例如，拥塞窗口 cwnd = 4，这时的往返时间 RTT 就是发送方连续发送 4 个报文段，并收到这 4 个报文段的确认，总共经历的时间。 </li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-dd19a95cf6c06f72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="慢开始算法.png"></p>
<h3 id="设置慢开始门限状态变量-ssthresh"><a href="#设置慢开始门限状态变量-ssthresh" class="headerlink" title="设置慢开始门限状态变量 ssthresh"></a>设置慢开始门限状态变量 ssthresh</h3><p>慢开始门限 ssthresh 的用法如下：</p>
<ul>
<li>当 cwnd &lt; ssthresh 时，使用慢开始算法。</li>
<li>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</li>
<li>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。</li>
</ul>
<p>拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍，使拥塞窗口 <strong>cwnd 按线性规律缓慢增长</strong>，比慢开始算法的拥塞窗口增长速率缓慢很多。</p>
<p><strong>网络出现拥塞时</strong></p>
<ul>
<li>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认），就要把慢开始门限 ssthresh 设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。</li>
<li>然后把拥塞窗口 cwnd 重新设置为 1，执行慢开始算法。</li>
<li>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。 </li>
</ul>
<h2 id="慢开始和拥塞避免算法的实现举例"><a href="#慢开始和拥塞避免算法的实现举例" class="headerlink" title="慢开始和拥塞避免算法的实现举例"></a>慢开始和拥塞避免算法的实现举例</h2><p>当 TCP 连接进行初始化时，将拥塞窗口置为 1。图中的窗口单位不使用字节而使用<strong>报文段</strong>。</p>
<p>慢开始门限的初始值设置为 16 个报文段，即 ssthresh = 16。</p>
<p>发送端的发送窗口不能超过拥塞窗口 cwnd 和接收端窗口 rwnd 中的最小值。我们假定接收端窗口足够大，因此现在发送窗口的数值等于拥塞窗口的数值。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-39c3cd16a7f4440f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="慢开始和拥塞避免算法的实现举例.png"></p>
<p><strong>下面的执行步骤就是按照折现上的点的顺序</strong></p>
<ol>
<li>在执行慢开始算法时，拥塞窗口 cwnd 的初始值为 1，发送第一个报文段 M0。  </li>
<li>发送端每收到一个确认 ，就把 cwnd 加 1。于是发送端可以接着发送 M1 和 M2 两个报文段。 </li>
<li>接收端共发回两个确认。发送端<strong>每收到一个</strong>对新报文段的确认，就把发送端的 cwnd 加 1。现在 cwnd 从 2 增大到 4，并可接着发送后面的 4 个报文段。 </li>
<li>发送端每收到一个对新报文段的确认，就把发送端的<strong>拥塞窗口</strong>加 1，因此拥塞窗口 cwnd 随着传输轮次按指数规律增长。 </li>
<li>当拥塞窗口 cwnd 增长到慢开始门限值 ssthresh 时（即当 cwnd = 16 时），就改为执行拥塞避免算法，拥塞窗口按线性规律增长。 </li>
<li>假定拥塞窗口的数值增长到 24 时，网络出现超时，表明网络拥塞了。 </li>
<li>更新后的 ssthresh 值变为 12（即发送窗口数值 24 的一半），拥塞窗口再重新设置为 1，并执行慢开始算法。 </li>
<li>当 cwnd = 12 时改为执行拥塞避免算法，拥塞窗口按按线性规律增长，每经过一个往返时延就增加一个 MSS 的大小。 </li>
</ol>
<p><strong>乘法减小（multiplicative decrease）</strong></p>
<ul>
<li>“乘法减小“是指不论在慢开始阶段还是拥塞避免阶段，只要出现一次超时（即出现一次网络拥塞），就把慢开始门限值 ssthresh 设置为当前的拥塞窗口值乘以 0.5。</li>
<li>当网络频繁出现拥塞时，ssthresh 值就下降得很快，以大大减少注入到网络中的分组数。 </li>
</ul>
<p><strong>加法增大（addictive increase）</strong><br>“加法增大”是指执行拥塞避免算法后，在收到对所有报文段的确认后（即经过一个往返时间），就把拥塞窗口 cwnd增加一个 MSS 大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。 </p>
<h3 id="要指出"><a href="#要指出" class="headerlink" title="要指出"></a>要指出</h3><ul>
<li>“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。</li>
<li>“拥塞避免”是说在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络<strong>比较不容易出现拥塞</strong>。 </li>
</ul>
<h2 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h2><h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h3><ul>
<li>快重传算法首先要求接收方每收到一个<strong>失序的报文段</strong>后就立即发出<strong>重复确认</strong>。这样做可以让发送方及早知道有报文段没有到达接收方。 </li>
<li>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段。 </li>
<li>不难看出，快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。 </li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-5a16662e601a391d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="快重传举例.png"><br><strong>对上图的解释请见P220</strong></p>
<h3 id="快恢复算法"><a href="#快恢复算法" class="headerlink" title="快恢复算法"></a>快恢复算法</h3><p>与快重传配合使用的还有<strong>快恢复</strong>算法</p>
<ul>
<li>当发送端收到连续三个重复的确认时，就执行“乘法减小”算法，把慢开始门限 ssthresh 减半。但接下去不执行慢开始算法。 </li>
<li>由于发送方现在认为网络<strong>很可能没有发生拥塞</strong>，因此现在不执行慢开始算法，即拥塞窗口 cwnd 现在不设置为 1，而是设置为慢开始门限 ssthresh 减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。 </li>
</ul>
<p><strong>从连续收到三个重复的确认传入拥塞避免（下图）</strong><br><img src="http://upload-images.jianshu.io/upload_images/1213532-21fd4748107bf23f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="从连续收到三个重复的确认传入拥塞避免.png"></p>
<h2 id="发送窗口的上限值"><a href="#发送窗口的上限值" class="headerlink" title="发送窗口的上限值"></a>发送窗口的上限值</h2><ul>
<li>发送方的发送窗口的上限值应当取为<strong>接收方窗口 rwnd</strong> 和<strong>拥塞窗口 cwnd</strong> 这两个变量中较小的一个，即应按以下公式确定：</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-421917285f348abb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="发送窗口的上限值.png"></p>
<p>当 rwnd &lt; cwnd 时，是接收方的接收能力限制发送窗口的最大值。<br>当 cwnd &lt; rwnd 时，则是网络的拥塞限制发送窗口的最大值。 </p>
<h2 id="随机早期检测RED（Random-Early-Detection）"><a href="#随机早期检测RED（Random-Early-Detection）" class="headerlink" title="随机早期检测RED（Random Early Detection）"></a>随机早期检测RED（Random Early Detection）</h2><p><strong>背景见P221</strong><br>使路由器的队列维持两个参数，即队列长度最小门限 THmin 和最大门限 THmax。<br>RED 对每一个到达的数据报都先计算平均队列长度 LAV。</p>
<ol>
<li>若平均队列长度小于最小门限 THmin，则将新到达的数据报放入队列进行排队。</li>
<li>若平均队列长度超过最大门限 THmax，则将新到达的数据报丢弃。</li>
<li>若平均队列长度在最小门限 THmin 和最大门限THmax 之间，则按照某一概率 p 将新到达的数据报丢弃。</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-647b934652df805d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="随机早期检测RED.png"></p>
<p>随机早期检测的随机就提现在3中，也就说，RED不是等到已经发生网络拥塞后才把所有在队列尾部的分组全部丢弃，而是在检测到网络拥塞的早期征兆时（即路由器的平均队列长度超过一定的门限值时），就先以概率p随机丢弃个别的分组，让拥塞控制只在个别的TCP连接上进行，因而避免发生全局性的拥塞控制。</p>
<p>最小门限应该足够大，以保证连接路由器的输出链路有较高的利用率。而最大门限和最小门限的差也应该足够大，使得在一个TCP往返时间RTT中队列的正常增长仍在最大门限之内。<strong>经验证明最大门限等于最小门限的两倍是合适的</strong></p>
<h2 id="丢弃概率-p-与-THmin-和-Thmax-的关系"><a href="#丢弃概率-p-与-THmin-和-Thmax-的关系" class="headerlink" title="丢弃概率 p 与 THmin 和 Thmax 的关系"></a>丢弃概率 p 与 THmin 和 Thmax 的关系</h2><ul>
<li>当 LAV &gt; Thmin 时，丢弃概率 p = 0。</li>
<li>当 LAV &lt; Thmax 时，丢弃概率 p = 1。</li>
<li>当 THmin &lt; LAV &lt; THmax时，  0 &lt; p &lt; 1 。<br>  例如，按线性规律变化，从 0 变到 pmax</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-ecb70d450f7b9846.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="丢弃概率 p 与 THmin 和 Thmax 的关系 .png"></p>
<p>为什么要用平均队列长度？我们知道计算机数据具有突发性的特点，因此路由器中的队列长度经常会出现很快的起伏变化。如果丢弃概率p按照瞬时队列长度来计算，那就可能会出现一些不合理的现象。例如<strong>很短的突发数据不大可能使队列溢出，因此对于这种数据，如果仅因为瞬时队列长度超过了门限值THmin就将其丢弃就会产生不必要的拥塞控制</strong></p>
<p><strong>下图也说明了这一点</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-8738a5342ac0a428.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="平均队列长度和瞬时队列长度的区别.png"></p>
<h2 id="平均队列长度以及p的计算"><a href="#平均队列长度以及p的计算" class="headerlink" title="平均队列长度以及p的计算"></a>平均队列长度以及p的计算</h2><p><strong>见P223</strong></p>
<h1 id="TCP运输连接管理"><a href="#TCP运输连接管理" class="headerlink" title="TCP运输连接管理"></a>TCP运输连接管理</h1><h2 id="运输连接的三个阶段"><a href="#运输连接的三个阶段" class="headerlink" title="运输连接的三个阶段"></a>运输连接的三个阶段</h2><ul>
<li>运输连接就有三个阶段，即：<strong>连接建立</strong>、<strong>数据传送</strong>和<strong>连接释放</strong>。运输连接的管理就是使运输连接的建立和释放都能正常地进行。</li>
</ul>
<p>连接建立过程中要解决以下三个问题：</p>
<ul>
<li>要使每一方能够确知对方的存在。</li>
<li>要允许双方协商一些参数（如最大报文段长度，最大窗口大小，服务质量等）。</li>
<li>能够对运输实体资源（如缓存大小，连接表中的项目等）进行分配。  </li>
</ul>
<p><strong>客户 - 服务器方式</strong><br>TCP连接的建立都是采用客户端服务器的方式，主动发起连接建立的应用进程叫做<strong>客户</strong>（client），被动等待连接建立的应用进程叫做<strong>服务器</strong>（server）</p>
<h2 id="TCP的连接建立（三次握手）"><a href="#TCP的连接建立（三次握手）" class="headerlink" title="TCP的连接建立（三次握手）"></a>TCP的连接建立（三次握手）</h2><p><img src="http://upload-images.jianshu.io/upload_images/1213532-f1318e72093ee051.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三次握手.png"><br><strong>本节在P225</strong></p>
<ol>
<li>B的TCP服务器进程先创建<strong>传输控制块TCB（transmission control block，存储了每一个连接中的一些重要信息：TCP连接表，到发送和接收缓存的指针，到重传队列的指针，当前的发送和接收序号等等）</strong>，准备接受客户进程的连接请求。然后服务器进程就处于LISTEN（收听）状态，等待客户的连接请求。如果有就作出响应</li>
<li>A的TCP客户进程也是首先创建传输控制块TCB，然后<strong>A 的 TCP 向 B 发出连接请求报文段，其首部中的同步位 SYN = 1，并选择序号 seq = x，表明传送数据时的第一个数据字节的序号是 x。</strong></li>
<li><strong>B 的 TCP 收到连接请求报文段后，如同意，则发回确认。B 在确认报文段中应使 SYN = 1，使 ACK = 1，其确认号ack = x + 1，自己选择的序号 seq = y。</strong></li>
<li><strong>A 收到此报文段后向 B 给出确认，其 ACK = 1，确认号 ack = y + 1。A 的 TCP 通知上层应用进程，连接已经建立。</strong>   </li>
<li>B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程：TCP 连接已经建立。</li>
</ol>
<p><strong>三次握手建立TCP连接的各状态</strong><br><img src="http://upload-images.jianshu.io/upload_images/1213532-3a7db5dc043dfdff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三次握手建立TCP连接的各状态.png"></p>
<h2 id="“三次”握手的原因"><a href="#“三次”握手的原因" class="headerlink" title="“三次”握手的原因"></a>“三次”握手的原因</h2><p>为什么A还要再发送一次数据呢？主要是为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。</p>
<p>所谓的“已失效的连接请求报文段”是这样产生的。</p>
<ul>
<li>考虑一种<strong>正常</strong>情况。A发送了连接请求，但是因为连接请求报文丢失而未收到确认。于是A再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A共发送了两个连接请求报文段，其中第一个丢失，第二个到达了B。没有“已失效的连接请求报文段 ”</li>
<li>现假定出现一种<strong>异常</strong>情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以至延误到连接释放后才到达B。本来这是一个早已经失效的报文段。但B收到此失效的连接请求报文后，就误认为是A又发来一次新的连接请求。于是就向A发送确认报文，同意建立连接。假定不采用三次握手，那么只要B发出确认，新的连接就建成了。由于现在A并没有建立连接的请求，因此并不会理睬B的确认，也不会向B发送数据，但是B却以为连接已经建立，并一直等待A发送数据，B的许多资源就这样白白浪费了。采用三次握手就可以防止上述现象的发生。例如在刚才的情况下，A不会向B的确认发出确认，B由于收不到第三次握手，就知道A并没有要求建立连接。</li>
</ul>
<h2 id="TCP连接的释放（四次握手）"><a href="#TCP连接的释放（四次握手）" class="headerlink" title="TCP连接的释放（四次握手）"></a>TCP连接的释放（四次握手）</h2><p><img src="http://upload-images.jianshu.io/upload_images/1213532-a351516be01e79fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP连接的释放.png"></p>
<ul>
<li>数据传输结束后，通信的双方都可释放连接。现在 A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP连接。A 把连接释放报文段首部的 FIN = 1，其序号seq = u（等于A前面传输的最后一个字节号+1），等待 B 的确认。</li>
<li>B 发出确认，确认号 ack = u + 1，而这个报文段自己的序号 seq = v（等于B前面传输的最后一个字节号+1）。TCP 服务器进程通知高层应用进程。从 A 到 B 这个方向的连接就释放了，TCP 连接处于<strong>半关闭</strong>状态。B 若发送数据，A 仍要接收。</li>
<li>若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接，序号为seq = w（在半关闭状态可能又发送了一些数据） ack = u+1（B还必须记录上次已发送的确认号）。 </li>
<li>A 收到连接释放报文段后，必须发出确认。在确认报文段中 ACK = 1，确认号 ack = w + 1，自己的序号 seq = u + 1。 </li>
<li>TCP 连接必须经过时间 2MSL （<strong>最长报文寿命</strong>）后才真正释放掉。 </li>
</ul>
<h3 id="A必须等待2MSL的时间"><a href="#A必须等待2MSL的时间" class="headerlink" title="A必须等待2MSL的时间"></a>A必须等待2MSL的时间</h3><ul>
<li>第一，为了保证 A 发送的最后一个 ACK 报文段能够到达 B。<br>这个报文段有可能丢失，因为使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认。B会超时重传这个FIN+ACK报文段，而A就能在这2MSL时间内收到这个重传的FIN+ACK报文段，接着A重传一次确认，<strong>重新启动2MSL计时器</strong>直到双方都关闭。</li>
<li>第二，防止 “已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段，<strong>都从网络中消失</strong>。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。<br>除时间等待计时器外，TCP还设有一个<strong>保活计时器</strong>，设想有这样的情况：客户已主动与服务器建立了TCP连接。但后来客户端的主机出现了故障。显然，服务器以后就不再收到客户发来的数据，因此，应当有措施使得服务器不会白白等下去。这就是使用保活器，时间设置通常为两小时，服务器每收到一次客户的数据，就重新设置保活器。若两小时每收到客户的数据，服务器就发送一个嗅探报文段，以后则每隔75分钟发送一次，若一连发送10个嗅探报文后客户端仍无响应，服务器就认定客户端发送故障，就关闭这个连接。</li>
</ul>
<h1 id="TCP有限状态机"><a href="#TCP有限状态机" class="headerlink" title="TCP有限状态机"></a>TCP有限状态机</h1><ul>
<li>TCP 有限状态机的图中每一个方框都是 TCP 可能具有的状态。</li>
<li>每个方框中的大写英文字符串是 TCP 标准所使用的 TCP 连接状态名。状态之间的箭头表示可能发生的状态变迁。</li>
<li>箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。</li>
<li>图中有三种不同的箭头。<ul>
<li><strong>粗实线箭头</strong>表示对客户进程的正常变迁。</li>
<li><strong>粗虚线箭头</strong>表示对服务器进程的正常变迁。</li>
<li><strong>另一种细线箭头</strong>表示异常变迁。 </li>
</ul>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-811b8781753f9b05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP有限状态机.png"></p>


                <hr>

                

                <ul class="pager">
                    
                    
                        <li class="next">
                            <a href="/2016/08/06/线程/" data-toggle="tooltip" data-placement="top" title="线程">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

            </div>
    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#计算机网络" title="计算机网络">计算机网络</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>

        </div>
    </div>
</article>




<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "hexo-theme-huxblog";
    var disqus_identifier = "http://github.com/srtianxia/srtianxia.github.io/2016/08/06/运输层/";
    var disqus_url = "http://github.com/srtianxia/srtianxia.github.io/2016/08/06/运输层/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("http://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/srtianxia">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/srtianxia">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/srtianxia">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Srtianxia&#39;s Blog 2016 
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    Ported by <a href="http://blog.kaijun.rocks">Kaijun</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://github.com/srtianxia/srtianxia.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("http://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->


<!-- Side Catalog -->





<!-- Image to hack wechat -->
<img src="http://github.com/srtianxia/srtianxia.github.io/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
