<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
          数据链路层 - Srtianxia | Srtianxia&#39;s Blog
        
    </title>

    <link rel="canonical" href="http://github.com/srtianxia/srtianxia.github.io/2016/08/06/数据链路层/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="http://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Srtianxia&#39;s Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archives/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="http://github.com/srtianxia/srtianxia.github.io/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/home-bg.jpg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#计算机网络" title="计算机网络">计算机网络</a>
                        
                    </div>
                    <h1>数据链路层</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        Posted by srtianxia on
                        2016-08-06
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <p>数据链路层使用的信道主要有以下两种类型</p>
<ul>
<li>点对点信道<br>这种信道使用一对一的点对点通信方式</li>
<li>广播信道<br>这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送<a id="more"></a>
</li>
</ul>
<p>数据链路层的简单模型-&gt;从层次上看数据的流动<br><img src="http://upload-images.jianshu.io/upload_images/1213532-298d4d46d97d4826.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据链路层的简单模型-&gt;从层次上看数据的流动.png"></p>
<p>数据链路层的简单模型-&gt;仅从数据链路层观察帧的流动<br><img src="http://upload-images.jianshu.io/upload_images/1213532-413d206cb6e1f183.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据链路层的简单模型-&gt;仅从数据链路层观察帧的流动.png"></p>
<h1 id="实用点对点信道的数据链路层"><a href="#实用点对点信道的数据链路层" class="headerlink" title="实用点对点信道的数据链路层"></a>实用点对点信道的数据链路层</h1><h2 id="数据链路和帧"><a href="#数据链路和帧" class="headerlink" title="数据链路和帧"></a>数据链路和帧</h2><ul>
<li><strong>链路</strong>（link）是一条无源的物理线路段，中间没有其他的交换结点。<ul>
<li>一条链路只是一条通路的一个组成部分</li>
</ul>
</li>
<li><strong>数据链路</strong>（data link）除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路<ul>
<li>现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件</li>
<li>一般的适配器都包括了数据链路层和物理层这两层的功能</li>
</ul>
</li>
</ul>
<p>数据链路层传送的是<strong>帧</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-8b51004c9457d24f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="模型.png"><br>图a为三层模型的简化模型， b为只考虑数据链路层</p>
<h1 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h1><p>数据链路层协议有许多中，但有三个基本问题是共同的，分别问<strong>封装成帧</strong>、<strong>透明传输</strong>、<strong>差错检验</strong></p>
<ul>
<li>封装成帧<br>封装成帧就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限，首部和尾部的一个重要作用就是进行<strong>帧定界</strong><br><img src="http://upload-images.jianshu.io/upload_images/1213532-cfa4b3732653cf79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="封装成帧.png"><br>每一种链路层协议都规定了所能传送的帧的<strong>数据部分长度上限-最大传送单元MTU（Maximum Transfer Unit）</strong><br><img src="http://upload-images.jianshu.io/upload_images/1213532-0f53d78244524aeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="帧.png"><ul>
<li>SOH （start of header）</li>
<li>EOT（end of transmission）<br><em>当数据在传输中出现差错时，帧定界符的作用更加明显，假定发送端尚未发送完一个帧时突然出现了故障，中断了发送。但随后很快又恢复正常，于是重新从头开始发送刚才未发送完的帧。由于使用了帧定界符，在接收端就知道前面收到的数据是个不完整的帧（只有首部没有尾部），必须丢弃。而后面收到的数据有明确的帧定界符（SOH和EOT），因此这是一个完整的帧，应当收下</em></li>
</ul>
</li>
<li>透明传输（在数据部分出现了首部和尾部的字符）<br><img src="http://upload-images.jianshu.io/upload_images/1213532-4640057498b54ad0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="透明传输.png"><br>解决透明传输问题<br><strong>透明</strong>是一个很重要的术语，他表示：<strong>某一个实际存在的事物看起来却是好像不存在一样</strong>，在数据链路层透明传输数据表示无论什么样的比特组合的数据都能够通过这个数据链路层，因此对所传送的数据来说，这些数据就“看不见”数据链路层有什么妨碍数据传输的东西。或者说，数据链路层对这些数据来说是透明的。<br>为了解决透明传输，就必须设法使数据中可能出现的控制字符SOH，EOT在接收端<strong>不被解释为控制字符</strong><ul>
<li>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”（其十六进制编码是1b）</li>
<li>字节填充（byte stuffing）或字符填充（character stuffing） – 接收端的数据链路层在将数据送往网络层之间删除插入的转义字符。</li>
<li>如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符。当接收端收到连续的两个转义字符，就删除前面的一个。<br><img src="http://upload-images.jianshu.io/upload_images/1213532-dad2a0022030f990.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="字节填充.png"></li>
</ul>
</li>
<li>差错检测<br>在传输过程中可能会产生比特差错：1可能会变成0而0也可能变成1，在一段时间内，传输错误的比特占所传输比特总数的比率称为<strong>误码率</strong>BER(Bit Error Rate)，误码率与<strong>信噪比</strong>有很大的关系，为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。在数据链路层传送的帧中，广泛使用了<strong>循环冗余检验CRC(Cyclic Redundancy Check)</strong>的检错技术<ul>
<li>在发送端，先把数据划分为组。假定每组k个比特</li>
<li>假设待传送的一组数据M = 101001（现在k = 6）。我们在M的<strong>后面再添加供差错检测</strong>用的n位<strong>冗余码</strong>一起发送。<br><strong>冗余码的计算</strong></li>
<li>用二进制的模2运算进行2^n * M运算，这相当于在M后面添加n个0</li>
<li>得到的（k+n）位的数除以事先选定好的长度为（n+1）位的除数P，得出商是Q而余数是R，余数R比除数P少1位，而R是n位。<br><strong>冗余码计算举例</strong></li>
<li>假设k = 6，M = 101001</li>
<li>假定除数P = 1101（即n=3）</li>
<li>被除数是2^n * M = 101001000(M后面添加n个0)</li>
<li>模2运算的结果是商Q = 110101 余数R = 001（即检验序列FCS Frame Check Sequence）</li>
<li>把余数作为<strong>冗余码</strong>添加在数据M的后面发送出去，即101001001<br><img src="http://upload-images.jianshu.io/upload_images/1213532-41f32f5e1861ef1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原理说明.png"><br><strong>注意p71的生成多项式</strong><br>顺便说下，循环冗余检验CRC和帧检验序列FCS并不是同一个概念。CRC是一种检错方法，而FCS是添加在数据后面的<strong>冗余码</strong>，在检错方法上可以选用CRC，但是也可以不选用CRC。<br><strong>接收端把接收到的数据以帧为单位进行CRC检验：把收到的每一帧都除以同样的除数P（模2运算），然后检查得到的余数R 若R = 0，则判定这个帧没有差错，就接受，若R ≠ 0，则判定这个帧有差错，就丢弃，这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错，只要经过严格挑选，并使用位数足够多的除数P，那么出现检测不到的差错的概率就很小很小</strong><br><strong>应当注意</strong></li>
<li>仅用循环冗余检验CRC差错检验技术只能做到无差错接受</li>
<li>无差错接受是指：“凡是接受的帧（即不包括丢弃的帧），我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错”</li>
<li>也就是说“凡是接收数据链路层接受的帧都没有传输差错（有差错的帧就丢弃而不接受）”</li>
<li>要做到“可靠传输（即发送什么就收到什么）”就必须加上<strong>确认</strong>和<strong>重传</strong>机制</li>
</ul>
</li>
</ul>
<h1 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h1><h2 id="PPP协议的特点"><a href="#PPP协议的特点" class="headerlink" title="PPP协议的特点"></a>PPP协议的特点</h2><p>现在全世界使用得最多的数据链路层协议是<strong>点对点协议PPP（Point-to-Point Protocol）</strong>，用户使用电话线接入因特网时，一般都是使用PPP协议。</p>
<p>用户到ISP的链路使用PPP协议</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-9d1679ada56b8397.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="用户到ISP的链路使用PPP协议.png"></p>
<h3 id="PPP协议应满足的需求"><a href="#PPP协议应满足的需求" class="headerlink" title="PPP协议应满足的需求"></a>PPP协议应满足的需求</h3><ul>
<li>简单<br>IEFT在设计因特网体系结构时，把最复杂的部分放在TCP协议中，而网际协议IP则相对比较简单，它提供的是不可靠的数据报服务，在这种情况下，数据链路层没有必要提供比IP协议更多的功能。因此对数据链路层的帧，不需要纠错，不需要流量控制，把简单作为<strong>首要的需求</strong><br>简单的设计可以使协议在实现时不容易出错，从而使不同厂商在协议的不同实现上其<strong>互操作性提高了</strong>，我们知道，协议标准化的一个主要目的就是提高协议的互操作性。<br>总之，这种数据链路层的协议非常简单：接收方每收到一个帧，就进行CRC检验，正确就收下这个帧；反之就丢弃这个帧，其他什么也不做。</li>
<li>封装成帧</li>
<li>透明性</li>
<li>多种网络层协议<br>PPP协议必须能够<strong>在同一条物理链路上同时支持多种网络协议（如ip和ipx）</strong>的运行。当点对点链路所连接的是局域网或路由器时，PPP协议必须同时支持在链路所连接的局域网或路由器上运行的各种网络层协议。</li>
<li>多种类型链路<br>除了要支持多种网络层的协议外，PPP还必须能够在多种类型的链路上运行。例如，串行的（一次只发送一个比特）或并行的（一次并行的发送多个比特），同步的或异步的，低速的或高速的，电的或光的，交换的（动态的）或非交换的（静态的）点对点链路。</li>
<li>差错检验</li>
<li>检测连接状态</li>
<li>最大传输单元<br>PPP必须对每一种类型的点对点链路设置最大传输单元MTU的标准默认值，这样是为了促进各种实现之间的互操作性。如果高层协议发送的分组过长并超过MTU的数值，PPP就要丢弃这样的帧，并返回差错。需要强调的是，MTU是数据链路层的帧可以载荷的<strong>数据部分</strong>，而不是帧的总长度</li>
<li>网络层地址协商</li>
<li>数据压缩协商</li>
</ul>
<h2 id="PPP协议的组成"><a href="#PPP协议的组成" class="headerlink" title="PPP协议的组成"></a>PPP协议的组成</h2><p>1992年制定了PPP协议，经过1993年和1994年的修订，现在的PPP协议已成为因特网的正式标准</p>
<h4 id="PPP协议有三个组成部分"><a href="#PPP协议有三个组成部分" class="headerlink" title="PPP协议有三个组成部分"></a>PPP协议有三个组成部分</h4><ul>
<li>一个将ip数据报封装到串行链路的方法</li>
<li><strong>链路控制协议LCP（Link Control Protocol）</strong></li>
<li><strong>网络控制协议NCP（Network Control Protocol）</strong></li>
</ul>
<h2 id="PPP协议的帧格式"><a href="#PPP协议的帧格式" class="headerlink" title="PPP协议的帧格式"></a>PPP协议的帧格式</h2><ul>
<li>标志字段F = 0x7E（符号“0x”表示后面的字符是用十六进制表示）</li>
<li>地址字段A只置位0xFF，地址字段实际上并不其作用。</li>
<li>控制字段C通常置位0x03</li>
<li>PPP是面向字节的，所有的PPP帧的长度都是整数字节</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-c8e2af941b1c0737.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PPP协议的帧格式.png"></p>
<h2 id="透明传输问题"><a href="#透明传输问题" class="headerlink" title="透明传输问题"></a>透明传输问题</h2><ul>
<li>当PPP用在同步传输链路时，协议规定采用硬件来完成比特填充（和HDLC的做法一样）</li>
<li>当PPP用在异步传输时，就使用一种特殊的<strong>字符填充法</strong></li>
</ul>
<h2 id="字节填充"><a href="#字节填充" class="headerlink" title="字节填充"></a>字节填充</h2><ul>
<li>将信息字段中出现的每一个0x7E字节转变为2字节序列（0x7D，0x5E）</li>
<li>若信息字段中出现一个0x7D的字节，则将其转变成为2字节序列（0x7D，0x5D）</li>
<li>若信息字段中出现ASC||码的控制字符（即数值小于0x20的字符），则在该字符前面要加入一个0x7D字节，同时将该字符的编码加以改变</li>
</ul>
<h2 id="零比特填充"><a href="#零比特填充" class="headerlink" title="零比特填充"></a>零比特填充</h2><ul>
<li>PPP协议用SONET/SDH链路时，是使用同步传输（一连串的比特连续传送）。这时PPP协议采用零比特填充方法来实现透明传输。</li>
<li>在发送端，只要发现有5个连续1，则立即填入一个0。接收端对帧中的比特流进行扫描。每当发现5个连续1时，就把这5个连续1后的一个0删除。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-7cc2d5219f5f743d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零比特填充.png"></p>
<h2 id="不提供使用序号和确认的可靠传输"><a href="#不提供使用序号和确认的可靠传输" class="headerlink" title="不提供使用序号和确认的可靠传输"></a>不提供使用序号和确认的可靠传输</h2><p>PPP协议之所以不使用序号和确认机制是出于以下的考虑</p>
<ul>
<li>在数据链路层出现差错的概率不大时，使用比较简单的PPP协议较为合理</li>
<li>在因特网环境下，PPP的信息字段放入的数据报是IP数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。</li>
<li>帧检验序列FCS字段可保证无差错接受</li>
</ul>
<h2 id="PPP协议的工作状态"><a href="#PPP协议的工作状态" class="headerlink" title="PPP协议的工作状态"></a>PPP协议的工作状态</h2><p>当用户拨号接入ISP时，路由器的<strong>调制解调器</strong>对拨号做出确认，并建立一条物理连接。PC机向路由器发送一系列的LCP分组（封装成多个PPP帧）。这些分组及其响应选择一些PPP参数，和进行网络层配置，NCP给新接入的PC机分配一个临时的IP地址，使PC机称为因特网上的一个主机。通信完毕时，NCP释放网络层连接，收回原来分配出去的IP地址。接着，LCP释放数据链路层连接。最后释放的是物理层的连接。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-04716c8d49922c9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PPP协议的工作状态.png"></p>
<h1 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h1><h2 id="局域网的数据链路层"><a href="#局域网的数据链路层" class="headerlink" title="局域网的数据链路层"></a>局域网的数据链路层</h2><p>局域网最主要的特点是：网络为一个单位所拥有，且地理范围和站点数目均有限。</p>
<p>局域网具有如下的一些主要优点：</p>
<ul>
<li>具有广播功能，从一个站点可很方便地访问全网，局域网上的主机可共享连接局域网上的各种硬件和软件资源</li>
<li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li>
<li>提高了系统的可靠性、可用性和生存性。</li>
</ul>
<h3 id="局域网的拓扑"><a href="#局域网的拓扑" class="headerlink" title="局域网的拓扑"></a>局域网的拓扑</h3><p><img src="http://upload-images.jianshu.io/upload_images/1213532-07ae4498f7e47628.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="局域网的拓扑.png"></p>
<h3 id="媒体共享技术"><a href="#媒体共享技术" class="headerlink" title="媒体共享技术"></a>媒体共享技术</h3><h4 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h4><ul>
<li>频分复用</li>
<li>时分复用</li>
<li>波分复用</li>
<li>码分复用</li>
</ul>
<p>静态划分信道的方法代价比较高，不适合于局域网使用</p>
<h4 id="动态媒体接入控制（多点接入）"><a href="#动态媒体接入控制（多点接入）" class="headerlink" title="动态媒体接入控制（多点接入）"></a>动态媒体接入控制（多点接入）</h4><ul>
<li>随机接入<br>随机接入的特点是所有的用户可以随机的发送信息，但如果恰巧有两个或者更多的用户在同一时刻发送信息，那么在共享媒体上就要产生碰撞（即发生了冲突），使得这些用户的发送都失败。因此，必须有解决碰撞的网络协议。</li>
<li>受控接入<br>特点是用户不能随机地发送信息而必须服从一定的控制。这类的典型代表有分散控制的令牌换局域网和集中控制的多点线路探寻（polling），或称为轮询。</li>
</ul>
<p>属于随机接入的以太网将被重点讨论，<strong>以太网已经在局域网市场中占据了绝对优势，现在以太网几乎成为了局域网的同义词</strong></p>
<h3 id="以太网的两个标准"><a href="#以太网的两个标准" class="headerlink" title="以太网的两个标准"></a>以太网的两个标准</h3><ul>
<li>DIX Ethernet V2是世界上第一个局域网产品（以太网）的规约。</li>
<li>IEEE的802.3标准</li>
<li>DIX Ethernet V2标准与IEEE的802.3标准只有很小的差别，因此可以将802.3局域网简称为“以太网”。</li>
<li>严格说来，“以太网”应当是符合DIX Ethernet V2标准的局域网。</li>
</ul>
<h3 id="数据链路层的两个子层"><a href="#数据链路层的两个子层" class="headerlink" title="数据链路层的两个子层"></a>数据链路层的两个子层</h3><p>为了使数据链路层能更好地适应多种局域网标准，802委员会就将<strong>局域网</strong>的数据链路层拆成两个子层：</p>
<ul>
<li>逻辑链路控制LLC（Logical Link Control） 子层</li>
<li>媒体接入控制MAC（Medium Access Control ）子层</li>
</ul>
<p>与接入到传输媒体有关的内容都放在MAC子层，而LLC子层则与传输媒体无关，不管采用何种协议的局域网对LLC子层来说都是透明的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-c79ccdebe7842198.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="局域网对LLC子层是透明的.png"></p>
<p><strong>以后一般不考虑LLC子层</strong></p>
<ul>
<li>由于TCP/IP体系经常使用的局域网是DIX Ethernet V2而不是802.3标准中的几种局域网，因此现在802委员会制定的逻辑链路子层LLC（即802.2标准）的作用已经不大了</li>
<li>很多厂商生产的适配器上就仅装有MAC协议而没有LLC协议</li>
</ul>
<h3 id="适配器的作用"><a href="#适配器的作用" class="headerlink" title="适配器的作用"></a>适配器的作用</h3><p>计算机与外界的局域网连接是通过通信适配器（adapter），适配器本来是在主机箱内插入的一块网络接口板，这种接口板又称<strong>网络接口卡NIC(NetWork Interface Card)</strong>或简称<strong>网卡</strong>，适配器也是一个小型计算机，有ROM和RAM</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li>进行串行/并行转换<br>适配器和局域网之间的通信是通过电缆或双绞线以串行传输方式进行的，而适配器和计算机之间的通信则是通过计算机主板上的I/O总线以并行传输方式进行的，因此适配器要进行数据串行和并行的转换</li>
<li>对数据进行缓存<br>网络上的数据率与计算机总线上的数据率不同，所有要缓存</li>
<li>在计算机的操作系统安装设备驱动程序<br>在主板上插入适配器时，要把驱动装入操作系统</li>
<li>实现以太网协议</li>
</ul>
<p>适配器所实现的功能包含了数据链路层和物理层这两层次的功能</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-fe6ccf39439874c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="计算机通过适配器和局域网进行通信.png"></p>
<h2 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA/CD协议"></a>CSMA/CD协议</h2><p>最初的以太网是将许多计算机都连接到一根总线上，当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件（那个时代认为有源器件不可靠（内部有电源的））<br>总线的特点是：当一台计算机发送数据时，总线上的所有计算机都能检测到这个数据，这就是广播通信方式。但我们并不总是要在局域网上进行一对多的广播通信，为了在总线上实现一对一的通信，可以使<strong>每一台计算机的适配器拥有一个与其他适配器都不同的地址，在发送数据帧时，在帧首部写明接收站的地址</strong>，仅当数据帧中的目的地址与适配器ROM中的存放的硬件地址一致时，该适配器才能接收这个帧，对于不是发送给自己的就丢弃，就实现了一对一通信</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-4ca5fb07fab416f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="总线.png"></p>
<p>人们也常把局域网上的计算机称为“主机”，“工作站”，“站点”或“站”。</p>
<h3 id="为了通信的简便，以太网采取了两种重要的措施"><a href="#为了通信的简便，以太网采取了两种重要的措施" class="headerlink" title="为了通信的简便，以太网采取了两种重要的措施"></a>为了通信的简便，以太网采取了两种重要的措施</h3><p>采用较为灵活的无连接的工作方式，即不必建立连接就可以直接发送数据，适配器对发送的数据帧<strong>不进行编号，也不要求对方发回确认</strong>，这样做可以使以太网工作起来非常简单，而局域网信道的质量很好，因通信质量不好产生差错的概率是很小的。因此，<strong>以太网提供的服务是尽最大努力的交付，即不可靠的交付</strong>，当目的站收到有差错的帧（CRC查出差错），就把帧抛弃，<strong>其他什么也不做</strong>。<strong>对有差错的帧是否需要重传则由高层决定</strong>。例如，如果高层使用TCP协议，那么TCP就会发现丢失了一些数据。于是经过一定时间后，TCP就把这些数据重新给以太网进行重传。<strong>但以太网并不知道这是帧重传，而是当做新的数据帧来发送的</strong><br>总线上只要有一台计算机在发送数据，总线的传输资源就被占用。因此，<strong>在同一时间只能允许一台计算机发送数据</strong>。<br>以太网采用最简单随机接入，但也有很好的协议来减少冲突的发生的概率，<strong>这就是载波监听多点接入/碰撞检测（CSMA/CD）</strong></p>
<ul>
<li><strong>多点接入</strong>表示许多计算机以多点接入的方式连接在一条总线上。</li>
<li><strong>载波监听</strong>是指每一个站在发送数据前要先检测一下总线上是否有其他计算机在发送数据，以免发生碰撞。总线上并没有什么“载波”，因此“载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。</li>
<li><strong>碰撞检测</strong>，计算机边发送数据边检测信道上的信号电压大小，当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加），当一个站检测到的信号电压摆动值超过一定门限时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，所谓<strong>碰撞</strong>就是发生了冲突。因此<strong>碰撞检测</strong>也称为冲突检测，在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来；每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。</li>
</ul>
<h4 id="以太网发送的数据都使用曼彻斯特（Manchester）编码的信号，我们知道，二进制基带数字信号通常就是高低电压交替出现的信号，使用这种信号的最大问题就是当出现一长串的连1或者连0时，接收端就无法从收到的比特流中提取比特同步信号，而曼彻斯特编码方法就是把每一个码元再分成两个相等的间隔。码元1是在前一个间隔为低电压而后一个为高电压，码元0正相反（也可采用相反的约定），但是曼彻斯特编码也有缺点，就是所占的频带宽度比原始的基带信号增加了一倍（每秒传送的码元数加倍了）"><a href="#以太网发送的数据都使用曼彻斯特（Manchester）编码的信号，我们知道，二进制基带数字信号通常就是高低电压交替出现的信号，使用这种信号的最大问题就是当出现一长串的连1或者连0时，接收端就无法从收到的比特流中提取比特同步信号，而曼彻斯特编码方法就是把每一个码元再分成两个相等的间隔。码元1是在前一个间隔为低电压而后一个为高电压，码元0正相反（也可采用相反的约定），但是曼彻斯特编码也有缺点，就是所占的频带宽度比原始的基带信号增加了一倍（每秒传送的码元数加倍了）" class="headerlink" title="以太网发送的数据都使用曼彻斯特（Manchester）编码的信号，我们知道，二进制基带数字信号通常就是高低电压交替出现的信号，使用这种信号的最大问题就是当出现一长串的连1或者连0时，接收端就无法从收到的比特流中提取比特同步信号，而曼彻斯特编码方法就是把每一个码元再分成两个相等的间隔。码元1是在前一个间隔为低电压而后一个为高电压，码元0正相反（也可采用相反的约定），但是曼彻斯特编码也有缺点，就是所占的频带宽度比原始的基带信号增加了一倍（每秒传送的码元数加倍了）"></a>以太网发送的数据都使用曼彻斯特（Manchester）编码的信号，我们知道，二进制基带数字信号通常就是高低电压交替出现的信号，使用这种信号的最大问题就是当出现一长串的连1或者连0时，接收端就无法从收到的比特流中提取比特同步信号，而曼彻斯特编码方法就是把每一个码元再分成两个相等的间隔。码元1是在前一个间隔为低电压而后一个为高电压，码元0正相反（也可采用相反的约定），但是曼彻斯特编码也有缺点，就是所占的频带宽度比原始的基带信号增加了一倍（每秒传送的码元数加倍了）</h4><p><img src="http://upload-images.jianshu.io/upload_images/1213532-f6b648d4d8defead.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="曼彻斯特（Manchester）编码.png"></p>
<p><strong>电磁波在总线上的有限传输速率的影响</strong><br>既然每一个站在发送数据之前已经监听到信道为<strong>空闲</strong>，那么为什么还会出现数据在总线上的碰撞呢？这是因为电磁波在总线上总是以有限的速率传播的。**这和我们开会时类似，一听见会场安静，我们就都立即发言，但偶尔也会发生几个人同时抢着发言而产生冲突的情况。</p>
<p><strong>传播时延对载波监听的影响</strong><br><img src="http://upload-images.jianshu.io/upload_images/1213532-8094a378f9f4541f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="传播时延对载波监听的影响.png"><br>电磁波在1km电缆的传播时延约为5μs，</p>
<p>//这里还有很多， 先跳过</p>
<h2 id="使用广播信道的以太网"><a href="#使用广播信道的以太网" class="headerlink" title="使用广播信道的以太网"></a>使用广播信道的以太网</h2><h3 id="使用集线器的星形拓扑"><a href="#使用集线器的星形拓扑" class="headerlink" title="使用集线器的星形拓扑"></a>使用集线器的星形拓扑</h3><p>传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。这种以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备（使用了大规模集成电路芯片所以可靠），叫做集线器（hub），双绞线以太网总是和集线器配合使用的。每个站需要用两对无屏蔽双绞线（放在一根电缆内），<strong>分别用于发送和接收</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-57592b17ed5a10f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用集线器的双绞线以太网.png"></p>
<h4 id="集线器的一些特点"><a href="#集线器的一些特点" class="headerlink" title="集线器的一些特点"></a>集线器的一些特点</h4><ul>
<li>集线器是使用电子器件来模拟实际电缆线的工作，因此整个系统仍像一根传统的以太网那样运行。</li>
<li>使用集线器的以太网在<strong>逻辑上</strong>仍是一个总线网，各工作站使用的还是CSMA/CD协议，并共享逻辑上的总线。</li>
<li>集线器很像一个多接口的转发器，工作在<strong>物理层</strong>。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-fb038097ce0cdb5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h4 id="以太网的信道利用率"><a href="#以太网的信道利用率" class="headerlink" title="以太网的信道利用率"></a>以太网的信道利用率</h4><p>// 这里还没看 p77</p>
<h2 id="以太网的MAC层"><a href="#以太网的MAC层" class="headerlink" title="以太网的MAC层"></a>以太网的MAC层</h2><p>在局域网中，硬件地址又称<strong>物理地址</strong>，或<strong>MAC地址</strong>。802标准所说的<strong>地址</strong>严格地讲应当是每一个站的<strong>名字</strong>或<strong>标识符</strong>，但鉴于大家早已习惯了将这种48位的<strong>名字</strong>称为<strong>地址</strong>，所以本书也采用这种习惯用法，尽管这种说法并不太严格。</p>
<h3 id="48位的MAC地址"><a href="#48位的MAC地址" class="headerlink" title="48位的MAC地址"></a>48位的MAC地址</h3><p>IEEE的注册管理机构RA负责向厂家分配地址字段的前三个字节（即高位24位），地址字段中的后三个字节（地位24位）由厂家自行指派，称为<strong>扩展标识符</strong>，必须保证生产出的适配器没有重复地址。一个地址块可以生成2^24个不同的地址。这种48位地址称为MAC-48，它的通用名称是EUI-48。MAC地址实际上就是适配器地址或适配器标识符EUI-48。</p>
<h3 id="适配器检查MAC地址"><a href="#适配器检查MAC地址" class="headerlink" title="适配器检查MAC地址"></a>适配器检查MAC地址</h3><p>适配器从网络上每收到一个MAC帧就首先用硬件检测MAC帧中的MAC地址</p>
<ul>
<li>如果是发往本站的帧则收下，然后再进行其他的处理</li>
<li>否则就将此帧丢弃，不再进行其他处理</li>
</ul>
<p><strong>发往本站的帧包括三种</strong></p>
<ul>
<li>单播（unicast）帧 一对一</li>
<li>广播（broadcast）帧 一对全体</li>
<li>多播（multicast）帧 一对多</li>
</ul>
<h3 id="MAC帧的格式"><a href="#MAC帧的格式" class="headerlink" title="MAC帧的格式"></a>MAC帧的格式</h3><p>常用的以太网MAC帧格式有两种标准：</p>
<ul>
<li>DIX Ethernet V2 （即以太网V2标准）标准</li>
<li>IEEE的802.3 标准</li>
</ul>
<p>最常用的MAC帧是以太网V2的格式，如图，假设网络层使用IP协议</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-7b0cd2982800cb5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MAC帧格式.png"><br>类型字段用来标志<strong>上一层</strong>使用的是什么协议，以便把收到的MAC帧的数据上交给上一层的这个协议。FCS是帧检验序列。</p>
<p>在这里要指出，在帧首部并没有一个<strong>帧长度</strong>，那么MAC子层又怎样知道从接收到的以太网帧中取出多少字节的数据交付上一层协议呢？曼彻斯特编码的一个重要特点就是：在曼彻斯特编码的每一个码元（不管码元是0还是1）的正中间一定有一次电压的转换，当发送方把一个以太网帧发送完毕后，就不再发送其他码元了。因此，发送方网络适配器的接口上的电压也就不再变化了，这样接收方就可以很容易地找到以太网帧的结束位置，在这个位置往前数4字节（FCS），就能确定数据字段的结束位置。</p>
<p>当数据字段的长度小于46字节时，应在数据字段的后面加入整数字节的<strong>填充字段</strong>，以保证以太网的MAC帧长度不少于64字节，我们应当注意到，MAC帧的首部并没有指出数据字段的长度是多少。在有填充字段的情况下，接收端的MAC子层在剥去首部和尾部后就把数据字段和填充字段一起交给上层协议。现在的问题是上层协议如何知道填充字段的长度呢？（IP协议应当丢弃没有用处的填充字段）。可见，上层协议必须具有<strong>识别有效的数据长度</strong>的功能。我们知道，上层使用IP协议时，<strong>其首部有一个总长度</strong>字段，因此<strong>总长度</strong>加上填充字段的长度，应当等于MAC数据帧数据字段的长度。例如，当IP数据报的总长度为42字节时，填充字段共有4字节。当MAC帧把46字节的数据上交给IP层后，IP层就把其中最后4字节的填充字段丢弃。</p>
<p>从上面的MAC帧图片看出，在传输媒体上实际传输的要比<strong>MAC帧</strong>还多8个字节。这是因为当一个站在刚开始接收MAC帧时，由于适配器的时钟尚未与到达的比特流达成同步，因此MAC帧最前面的若干位就无法接收，结果使整个MAC帧变成无用的帧。<strong>为了接收端迅速实现位同步，由MAC子层向下传到物理层时还要在帧的前面插入8字节（由硬件生成），它由两个字段构成。第一个字段是7个字节的前同步码，用来迅速实现MAC帧的比特同步，第二个字段是帧开始定界符，表示后面的信息就是MAC帧</strong></p>
<p>  MAC帧的FCS字段的检验范围不包括前同步码和帧开始界定符，顺便指出，在使用SONET/SDH（同步光纤网）进行同步传输时，则不需要前同步码，因为在同步传输时收发双方的位同步总是一直保持着的。</p>
<p><strong>还需注意</strong>，在以太网上传送数据时是以帧为单位传输，以太网在传输帧时，各帧之间还必须有一定的<strong>间隙</strong>。因此，接收端只要找到帧开始定界符，其后面的连续到达的比特流就都属于同一个MAC帧。可见以太网不需要使用帧结束定界符，也不需要使用字节插入来保证透明传输。</p>
<h4 id="IEEE规定凡是出现下列情况之一的即为无效的MAC帧"><a href="#IEEE规定凡是出现下列情况之一的即为无效的MAC帧" class="headerlink" title="IEEE规定凡是出现下列情况之一的即为无效的MAC帧"></a>IEEE规定凡是出现下列情况之一的即为无效的MAC帧</h4><ul>
<li>帧的长度不是整数个字节</li>
<li>用收到的帧检验序列FCS查出有差错</li>
<li>数据字段的长度不在46 - 1500字节之间（有效的MAC帧长度为64 - 1518字节之间）</li>
</ul>
<p>对于检查出的无效MAC帧就简单地丢弃，以太网不负责重传丢弃的帧。</p>
<h4 id="帧间最小间隔"><a href="#帧间最小间隔" class="headerlink" title="帧间最小间隔"></a>帧间最小间隔</h4><ul>
<li>帧间最小间隔为9.6μs，相当于96bit的发送时间</li>
<li>一个站在检测到总线开始空闲后还要等待9.6μs才能再次发送数据</li>
<li>这样是为了使刚刚收到数据帧的站的接受缓存来得及清理，做好接受下一帧的准备</li>
</ul>
<h2 id="扩展的以太网"><a href="#扩展的以太网" class="headerlink" title="扩展的以太网"></a>扩展的以太网</h2><p>（PS 以太网已经是局域网的代名词，在这里讨论以太网）<br>在很多情况下，我们希望把以太网的覆盖范围扩展，本节先讨论在<strong>物理层</strong>把以太网扩展，<strong>这种扩展的以太网在网络层看来仍然是一个网络</strong></p>
<h3 id="在物理层扩展以太网"><a href="#在物理层扩展以太网" class="headerlink" title="在物理层扩展以太网"></a>在物理层扩展以太网</h3><p>过去采用<strong>转发器</strong>来扩展以太网的地理覆盖范围，现在随着双绞线以太网称为以太网的主流类型，扩展以太网的覆盖范围已经很少使用转发器了。</p>
<p>现在，扩展主机和集线器之间的距离的一种简单方法就是使用光纤和一对光纤调制解调器（进行光信号和电信号的转换），由于光纤带来的时延很小，而且带宽很高，因此使用这种方法可以很容易地使主机和几公里以外的<strong>集线器</strong>相连接。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-84dbd9f5be272552.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="光纤/光纤调制解调器.png"></p>
<p>如果使用多个集线器，就可以连接成覆盖范围更大的多级星型结构的以太网<br>例如，某大学有三个系，各自有一个局域网，可以通过一个主干集线器把各系的以太网连接起来，成为一个更大的以太网</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-c312b0d179c8ddb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三个独立.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-24d1677a6dec0160.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一个更大的碰撞域.png"></p>
<h4 id="用集线器扩展局域网"><a href="#用集线器扩展局域网" class="headerlink" title="用集线器扩展局域网"></a>用集线器扩展局域网</h4><h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ul>
<li>使原来不同碰撞域的局域网上的计算机能够进行跨碰撞域的通信</li>
<li>扩大的局域网覆盖的地理范围</li>
</ul>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><ul>
<li>碰撞域增大了，但总的吞吐量并未提高</li>
<li>如果不同的碰撞域使用不同的数据率，那么就不用集线器将它们互联起来</li>
</ul>
<h3 id="在数据链路层扩展以太网"><a href="#在数据链路层扩展以太网" class="headerlink" title="在数据链路层扩展以太网"></a>在数据链路层扩展以太网</h3><ul>
<li>在数据链路层扩展局域网是使用<strong>网桥</strong></li>
<li>网桥工作时在数据链路层，它根据MAC帧的目地址对收到的帧进行转发</li>
<li>网桥具有过滤帧的功能，当网桥收到一个帧时，并不是向所有接口转发此帧，而是先检查此帧的目的MAC地址，然后再确定将该帧转发到哪一个接口</li>
</ul>
<p>网桥的内部结构<br><img src="http://upload-images.jianshu.io/upload_images/1213532-95663092d5c4079f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网桥的内部结构.png"></p>
<p>最简单的网桥有两个接口，复杂些的网桥可以有更多的接口，两个以太网通过网桥连接起来后，就成为一个覆盖范围更大的以太网，而原来的每个以太网就可以称为一个<strong>网段</strong>。</p>
<p>网桥依靠转发表来转发帧，转发表也叫作<strong>转发数据库</strong>或<strong>路由目录</strong>。一个转发的例子在课本P95</p>
<h6 id="使用网桥带来的好处"><a href="#使用网桥带来的好处" class="headerlink" title="使用网桥带来的好处"></a>使用网桥带来的好处</h6><ul>
<li>过滤通信量，增大吞吐量<br>过滤通信量在书中的含义：可以使以太网各网段成为隔开的碰撞区（个人理解）<br>假如A与C进行通信，这时这两个网段上就不能再有其他站点进行通信（但是EF还可以通信）（要是采用集线器或者转发器，那么整个网络还是一个碰撞区），假设三个网段的数据率都是10mb/s，那么合起来的最大吞吐量就变成30mb/s但是集线器或者转发器还是10mb/s。<br><img src="http://upload-images.jianshu.io/upload_images/1213532-24749d7aeff48b4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三个网段.png"></li>
<li>扩大了物理范围</li>
<li>提高了可靠性<br>网络出现故障时，一般只影响个别网段</li>
<li>可互连不同的物理层、不同MAC子层和不同速率的局域网</li>
</ul>
<h6 id="使用网桥带来的缺点"><a href="#使用网桥带来的缺点" class="headerlink" title="使用网桥带来的缺点"></a>使用网桥带来的缺点</h6><ul>
<li>存储转发增加了时延（查表）</li>
<li>在MAC子层并没有流量控制功能<br>当网络上负荷很重时，网桥中的缓存的存储空间可能不够而发生溢出，以致产生帧丢失的现象</li>
<li>具有不同MAC子层的网段桥接在一起时时延更大</li>
<li>网桥只适合于用户数不太多（不超过几百个）和通信量不太大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞。这就是所谓的<strong>广播风暴</strong>。</li>
</ul>
<p>有时在两个网桥之间，还可以使用一段点到点链路</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-acd7e95d151e0ac0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网桥使用一段点到点链路.png"><br>网桥在转发帧时<strong>不改变帧的源地址</strong></p>
<h6 id="网桥和集线器（转发器）的不同"><a href="#网桥和集线器（转发器）的不同" class="headerlink" title="网桥和集线器（转发器）的不同"></a>网桥和集线器（转发器）的不同</h6><ul>
<li>集线器在转发帧时，不对媒体进行检测</li>
<li>网桥在转发帧之前必须执行CSMA/CD算法，在发送过程中出现碰撞，就必须停止发送和进行退避。</li>
</ul>
<h4 id="透明网桥"><a href="#透明网桥" class="headerlink" title="透明网桥"></a>透明网桥</h4><p>目前使用得最多的网桥是<strong>透明网桥</strong>，透明指得是局域网上的站点并不知道所发送的帧将经过哪几个网桥，因为网桥对各站来说是看不见的。透明网桥是一种即插即用设备，其标准是IEEE 802.1D。</p>
<p>当网桥刚刚连接到以太网时，其转发表是空的，所以网桥按照<strong>自学习算法</strong>处理收到的帧和建立转发表。</p>
<p>这种自学习算法的原理：</p>
<ul>
<li>若从A发出的帧从接口x进入了某网桥，那么从这个接口出发沿相反方向一定可把一个帧传送到A</li>
<li>网桥每收到一个帧，就记下其<strong>源地址</strong>和<strong>进入网桥的接口</strong>，作为转发表中的一个项目</li>
<li>在建立转发表时是把帧首部中的<strong>源地址</strong>写在地址这一栏的下面</li>
<li>在转发帧时，则是根据收到的帧首部中的<strong>目的地址</strong>来转发的。这时就把地址栏下面已经记下的<strong>源地址</strong>当作目的地址，而把记下的进入接口当作<strong>转发接口</strong> </li>
</ul>
<p><strong>转发表中的地址在自学习和转发的时候扮演的角色不同</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-261c8bc4a2c4c821.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="转发表的建立过程举例.png"></p>
<h5 id="网桥在转发表中登记以下三个信息"><a href="#网桥在转发表中登记以下三个信息" class="headerlink" title="网桥在转发表中登记以下三个信息"></a>网桥在转发表中登记以下三个信息</h5><p>在网桥的转发表中写入的信息除了<strong>地址</strong>和<strong>接口</strong>外，还有帧进入该网桥的<strong>时间</strong>。这是因为以太网的拓扑可能会发生变化，站点也可能会更换适配器（这样就改变了站点的地址）。另外，以太网上的工作站并非总是接通电源的，把每个帧到达网桥的时间登记下来，就可以在转发表中国只保留网络拓扑的<strong>最新状态信息</strong>。这样就使得网桥中的转发表能反映当前网络的最新拓扑状态。</p>
<h5 id="网桥自学习和转发帧的步骤归纳"><a href="#网桥自学习和转发帧的步骤归纳" class="headerlink" title="网桥自学习和转发帧的步骤归纳"></a>网桥自学习和转发帧的步骤归纳</h5><p>网桥收到一帧后先进行<strong>自学习</strong>。查找转发表中与收到帧的<strong>源地址</strong>有无匹配的项目。如没有，就在转发表中增加一个项目（源地址，接入的接口和时间）。如有，则把原有的项目进行更新。</p>
<p><strong>转发帧</strong>，查找转发表中与收到帧的目的地址有无匹配的项目。</p>
<ul>
<li>如没有，则通过所有其他接口（但进入网桥的接口除外）按进行转发</li>
<li>如有，则按转发表中给出的接口进行转发</li>
<li>若转发表中给出的接口就是该帧进入网桥的接口，则应丢弃这个帧（因为此时不需要经过网桥进行转发）</li>
</ul>
<h5 id="透明网桥使用了生成树算法"><a href="#透明网桥使用了生成树算法" class="headerlink" title="透明网桥使用了生成树算法"></a>透明网桥使用了生成树算法</h5><p>为了避免产生转发的帧在网络中不断地兜圈子</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-daac95028660d4f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="兜圈子的情况.png"></p>
<p><strong>生成树的得出</strong></p>
<ul>
<li>互连在一起的网桥在彼此通信后，就能找出原来的网络拓扑的一个子集。在这个子集里，整个联通的网络中不存在回路，<strong>即在任何两个站之间只有一条路径</strong></li>
<li>为了避免产生转发的帧在网络中不断地兜圈子</li>
<li>为了得出能够反映网络拓扑发生变化时的生成树，在生成树上的根网桥每隔一段时间还要对生成树的拓扑进行更新</li>
</ul>
<h4 id="源路由网桥"><a href="#源路由网桥" class="headerlink" title="源路由网桥"></a>源路由网桥</h4><p>透明网桥容易安装，但网络资源的利用不充分。 p100</p>
<p><strong>源路由（source route）</strong>网桥发送帧时将详细的路由信息放在帧的首部中，源站以广播方式向欲通信的目的站发送一个发现帧（作为探测使用），每个发现帧都记录所经过的路由。</p>
<p>发现帧到达目的站时就沿各自的路由返回源站，源站在得知这些路由后，从所有可能的路由中选择一个最佳路由。凡从该源站向目的站发送的帧的首部，都必须携带源站所确定的这一路由信息。</p>
<h4 id="多接口网桥-以太网交换机"><a href="#多接口网桥-以太网交换机" class="headerlink" title="多接口网桥 - 以太网交换机"></a>多接口网桥 - 以太网交换机</h4><ul>
<li>1990年问世的<strong>交换式集线器</strong>（switching hub），可明显地提高局域网的性能。</li>
<li>交换式集线器称为<strong>以太网交换机</strong>或<strong>第二层交换机</strong>（表明此交换机工作在数据链路层）</li>
<li>以太网交换机通常都有十几个接口。因此，以太网交换机实质上就是一个<strong>多接口的网桥</strong>，可见交换机工作在数据链路层。</li>
</ul>
<h5 id="以太网交换机的特点"><a href="#以太网交换机的特点" class="headerlink" title="以太网交换机的特点"></a>以太网交换机的特点</h5><ul>
<li>以太网交换机的每个接口都直接与主机相连，并且一般都工作在<strong>全双工方式</strong></li>
<li>交换机能同时连通许多对的接口，使每一对相互通信的主机都能像独占通信媒体那样，进行无碰撞地传输数据</li>
<li>以太网交换机由于使用了专用的交换结构芯片，其交换速率就较高</li>
</ul>
<p>许多以太网交换机对收到的帧采用存储转发方式进行转发，但是也有一部分采用<strong>直通</strong>的交换方式。直通交换不必把整个数据帧先缓存后再进行处理，而是在接收数据帧的同时按数据帧的目的MAC地址觉得该帧的转发接口，因而提高了帧的转发速度。如果在这种交换机的内部采用基于硬件的交叉矩阵交换时延就非常小。直通交换机一个缺点就是它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。在某些情况下，仍需要采用基于软件的存储转发方式进行交换，例如，当需要进行线路速率匹配、协议转换或差错检测时。现在有的厂商已经生产出能支持两种交换方式的交换机。</p>
<p><strong>独占传输媒体的带宽</strong></p>
<ul>
<li>对于普通10Mb/s的共享式以太网，若有N个用户，则每个用户的平均带宽只有10Mb/s的N分之一。</li>
<li>使用以太网交换机时，虽然在每个接口到主机的带宽还是10Mb/s，但由于一个用户在通信时是独占而不是和其他用户共享传输媒体的带宽，因此对于拥有N对接口的交换机的总容量为N*10Mb/s。这正是交换机的最大优点。</li>
</ul>
<p>以太网交换机一般都具有多种速率的接口，大大方便了各种不同情况的用户。</p>
<h5 id="以太网交换机实现虚拟局域网"><a href="#以太网交换机实现虚拟局域网" class="headerlink" title="以太网交换机实现虚拟局域网"></a>以太网交换机实现虚拟局域网</h5><ul>
<li>虚拟局域网VLAN是由一些局域网网段构成的与物理位置无关的逻辑组。<ul>
<li>这些网段具有某些共同的需求。</li>
<li>每一个VLAN的帧都有一个明确的标识符，指明发送这个帧的工作站是属于哪一个VLAN。</li>
</ul>
</li>
<li>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-c613f5614b0b3039.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="虚拟局域网.png"></p>
<p>使用以太网交换机很方便的将这10个工作站划分为三个虚拟局域网</p>
<p>当 B1 向 VLAN2 工作组内成员发送数据时，工作站 B2 和 B3 将会收到广播的信息。</p>
<p>B1 发送数据时，工作站 A1, A2 和 C1都不会收到 B1 发出的广播信息。<br>虚拟局域网限制了接收广播信息的工作站数，使得网络不会因传播过多的广播信息(即“广播风暴”)而引起性能恶化。 </p>
<h6 id="虚拟局域网使用以太网帧格式"><a href="#虚拟局域网使用以太网帧格式" class="headerlink" title="虚拟局域网使用以太网帧格式"></a>虚拟局域网使用以太网帧格式</h6><p>虚拟局域网协议允许在以太网的帧格式中插入一个 4 字节的标识符，称为 VLAN 标记(tag)，用来指明发送该帧的工作站属于哪一个虚拟局域网。 </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-ebbd9294bb61fe61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="虚拟局域网使用以太网帧格式.png"></p>
<h2 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h2><p>//这部分不打算看</p>


                <hr>

                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2016/08/06/死锁/" data-toggle="tooltip" data-placement="top" title="死锁">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2016/08/06/设计模式_代理模式/" data-toggle="tooltip" data-placement="top" title="代理模式">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

            </div>
    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#计算机网络" title="计算机网络">计算机网络</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>

        </div>
    </div>
</article>




<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "hexo-theme-huxblog";
    var disqus_identifier = "http://github.com/srtianxia/srtianxia.github.io/2016/08/06/数据链路层/";
    var disqus_url = "http://github.com/srtianxia/srtianxia.github.io/2016/08/06/数据链路层/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("http://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/srtianxia">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/srtianxia">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/srtianxia">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Srtianxia&#39;s Blog 2016 
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    Ported by <a href="http://blog.kaijun.rocks">Kaijun</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://github.com/srtianxia/srtianxia.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("http://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->


<!-- Side Catalog -->





<!-- Image to hack wechat -->
<img src="http://github.com/srtianxia/srtianxia.github.io/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
