<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
          网络层 - Srtianxia | Srtianxia&#39;s Blog
        
    </title>

    <link rel="canonical" href="http://github.com/srtianxia/srtianxia.github.io/2016/08/06/网络层/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="http://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Srtianxia&#39;s Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archives/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="http://github.com/srtianxia/srtianxia.github.io/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/home-bg.jpg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#计算机网络" title="计算机网络">计算机网络</a>
                        
                    </div>
                    <h1>网络层</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        Posted by srtianxia on
                        2016-08-06
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h1><p>在计算机网络领域，网络层应该向运输层提供怎样的服务（面向连接还是无连接）曾引起了长期的争论，争论焦点的实质就是：在计算机通信中，可靠交付应当由谁来负责？是<strong>网络</strong>还是<strong>端系统</strong></p>
<h2 id="电信网的成功经验让网络负责可靠交付"><a href="#电信网的成功经验让网络负责可靠交付" class="headerlink" title="电信网的成功经验让网络负责可靠交付"></a>电信网的成功经验让网络负责可靠交付</h2><ul>
<li><strong>面向连接</strong>的通信方式</li>
<li>建立<strong>虚电路（Virtual Circuit）</strong>，以保证双方通信所需的一切网络资源</li>
<li>如果再使用可靠传输的网络协议，就可使所发送的分组无差错按序到达终点<a id="more"></a>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-9bab3c0f95453abe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="虚电路.png"></p>
<h2 id="虚电路是逻辑连接"><a href="#虚电路是逻辑连接" class="headerlink" title="虚电路是逻辑连接"></a>虚电路是逻辑连接</h2><p>只是一条<strong>逻辑上的连接</strong>，分组都沿着这条逻辑连接按照存储转发方式传送，并不是真正建立了一条物理连接。</p>
<p>请注意，电路交换的<strong>电话通信</strong>是先建立了一条<strong>真正的连接</strong>。因此分组交换的虚连接和电路交换的连接只是类似，但并不完全一样。</p>
<h2 id="因特网采用的设计思路"><a href="#因特网采用的设计思路" class="headerlink" title="因特网采用的设计思路"></a>因特网采用的设计思路</h2><ul>
<li>网络层向上只提供简单灵活的、<strong>无连接的</strong>、<strong>尽最大努力交付</strong>的<strong>数据报服务</strong></li>
<li>网络在发送分组时不需要先建立连接。每一个分组（即IP数据报）独立发送，与其前后的分组无关（不进行编号）</li>
<li>网络层不提供服务质量的承诺，即所传输的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传输的时限</li>
</ul>
<h3 id="尽最大努力交付的好处"><a href="#尽最大努力交付的好处" class="headerlink" title="尽最大努力交付的好处"></a>尽最大努力交付的好处</h3><ul>
<li>由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）</li>
<li>如果主机（端系统）中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层来负责（包括差错处理，流量控制等）</li>
<li>采用这种设计思路的好处是：网络的造价大大降低，运行方式灵活，能够适应多种应用</li>
<li>因特网能够发展到今日的规模，充分证明了当初采用这种设计思路的正确性</li>
</ul>
<p>数据报服务<br><img src="http://upload-images.jianshu.io/upload_images/1213532-8449634664011e7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据报服务.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-735792081d308232.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="虚电路和数据报服务的对比.png"></p>
<h2 id="网际协议IP"><a href="#网际协议IP" class="headerlink" title="网际协议IP"></a>网际协议IP</h2><p>网际协议IP是TCP/IP体系中两个最主要的协议之一，与IP协议配套使用的还有三个协议</p>
<ul>
<li>地址解析协议ARP （Address Resolution Protocol）</li>
<li>网际控制报文协议ICMP（Internet Control Message Protocol）</li>
<li>网际组管理协议IGMP（Internet Group Management Protocol）</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-b01c9be151fd2a79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网际IP层协议及配套协议.png"></p>
<h3 id="虚拟互连网络"><a href="#虚拟互连网络" class="headerlink" title="虚拟互连网络"></a>虚拟互连网络</h3><p>互连在一起的网络要进行通信，会遇到许多问题要解决<br><img src="http://upload-images.jianshu.io/upload_images/1213532-9f1bfba6b3d6650c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="问题.png"></p>
<p><strong>网络互连要使用一些中间设备</strong><br><strong>中间设备</strong>又称为<strong>中间系统</strong>或<strong>中继</strong>系统</p>
<ul>
<li>物理层中继系统  <strong>转发器</strong></li>
<li>数据链路层中继系统  <strong>网桥或桥接器</strong></li>
<li>网络层中继系统  <strong>路由器</strong></li>
<li>网桥和路由器的混合物  <strong>桥路由</strong></li>
<li>网络层以上的中继系统  <strong>网关</strong></li>
</ul>
<h3 id="网络互连使用路由器"><a href="#网络互连使用路由器" class="headerlink" title="网络互连使用路由器"></a>网络互连使用路由器</h3><ul>
<li>当中继系统是转发器或网桥时，一般<strong>并不称之为网络互连</strong>，因为这仅仅是把一个<strong>网络扩大了</strong>，而这仍然是一个网络。</li>
<li>网关由于比较复杂，目前使用的较少</li>
<li>互联网都是指用路由器进行互连的网络</li>
<li>由于历史原因，许多有关TCP/IP的文献将网络层使用的路由器称为<strong>网关</strong></li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-7de41405b9db3b93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="互联网络与虚拟网络.png"></p>
<h4 id="虚拟互连网络的意义"><a href="#虚拟互连网络的意义" class="headerlink" title="虚拟互连网络的意义"></a>虚拟互连网络的意义</h4><ul>
<li>所谓虚拟互连网络也就是逻辑互连网络，它的意思就是互连起来的各种物理网络的异构性本来是客观存在的，但是我们利用IP协议就可以使这些性能各异的网络从用户看起来好像是一个统一的网络。</li>
<li>使用IP协议的虚拟互连网络可简称为IP网</li>
<li>使用虚拟互联网络的好处是：当互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互连的各具体网络异构细节</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-95bacf6e64d6d8c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分组在互联网中的传送.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-39fbd0f83d775fe1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网络层.png"></p>
<p>如果我们只从网络层考虑问题，那么IP数据报就可以想象是在网络层中传送。</p>
<h2 id="分类的IP地址"><a href="#分类的IP地址" class="headerlink" title="分类的IP地址"></a>分类的IP地址</h2><h3 id="IP地址及其表示方法"><a href="#IP地址及其表示方法" class="headerlink" title="IP地址及其表示方法"></a>IP地址及其表示方法</h3><ul>
<li>我们把整个因特网看成为一个单一的抽象的网络。IP地址就是给每个连接在因特网上的主机（或路由器）分配一个在全世界范围是唯一的32位的标识符。</li>
<li>IP地址现在由因特网名字与号码指派公司进行分配</li>
</ul>
<h3 id="IP地址的编制方法"><a href="#IP地址的编制方法" class="headerlink" title="IP地址的编制方法"></a>IP地址的编制方法</h3><ul>
<li><strong>分类的IP地址</strong>，这是最基本的编制方法，在1981年就通过了相应的标准协议</li>
<li><strong>子网的划分</strong>，这是对最基本的编制方法的改进，其标准[RFC 950]在1985年通过的</li>
<li><strong>构成超网</strong>，这是比较新的无分类编制方法。1993年后很快就得到推广应用</li>
</ul>
<h3 id="分类IP地址"><a href="#分类IP地址" class="headerlink" title="分类IP地址"></a>分类IP地址</h3><p>每一类地址都由两个固定长度的字段组成，其中一个 字段是<strong>网络号 net-id</strong>，它标志主机（或路由器）所连接到的网络，而另一个字段则是<strong>主机号 host-id
</strong>，它标志该主机（或路由器）<br>可以记为</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-433788598f731783.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分类IP地址.png"></p>
<h3 id="IP地址中的网络号字段和主机号字段"><a href="#IP地址中的网络号字段和主机号字段" class="headerlink" title="IP地址中的网络号字段和主机号字段"></a>IP地址中的网络号字段和主机号字段</h3><p><img src="http://upload-images.jianshu.io/upload_images/1213532-19d826edadad3fe3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IP地址中的网络号字段和主机号字段.png"></p>
<ul>
<li>A类、B类、C类地址的网络号字段分别为<strong>1，2，3字节</strong>长，而在网络号字段的最前面有1-3位的<strong>类别位</strong>，其数值分别规定为0，10，和110。</li>
<li>D类地址用于多播（一对多通信）</li>
<li>E类地址保留为以后用</li>
</ul>
<h3 id="点分十进制记法"><a href="#点分十进制记法" class="headerlink" title="点分十进制记法"></a>点分十进制记法</h3><p><img src="http://upload-images.jianshu.io/upload_images/1213532-256041a4daa467dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="点分十进制记法.png"></p>
<h3 id="常用的三种类别的IP地址"><a href="#常用的三种类别的IP地址" class="headerlink" title="常用的三种类别的IP地址"></a>常用的三种类别的IP地址</h3><p><img src="http://upload-images.jianshu.io/upload_images/1213532-2e7a422e62393f09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="常用的三种类别的IP地址.png"></p>
<h3 id="IP地址的一些重要特点"><a href="#IP地址的一些重要特点" class="headerlink" title="IP地址的一些重要特点"></a>IP地址的一些重要特点</h3><ul>
<li>IP地址是一种分等级的地址结构，分两级的好处是<ul>
<li>IP地址管理机构在分配IP地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便的IP地址的管理</li>
<li>路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目大幅度减小，从而减少了路由表所占的存储空间。</li>
</ul>
</li>
<li>实际上IP地址是标志一个<strong>主机（或路由器）和一条链路的接口</strong><ul>
<li>当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的IP地址，其网络号net-id必须是不同的。这种主机称为<strong>多归属主机</strong></li>
<li>由于一个路由器至少应当连接到两个网络（这样它才能将IP数据报从一个网络转发到另一个网络），因此一个路由器至少应当有两个不同的IP地址</li>
</ul>
</li>
<li>用转发器或网桥连接起来的若干个局域网仍为一个网络，因此这些局域网都具有相同的网络号 net-id</li>
<li>所有分配到网络号net-id的网络，范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-5c4653940ec981c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="同一局域网.png"></p>
<p>观察上图</p>
<ul>
<li>在同一局域网上的主机或路由器的IP地址中的<strong>网络号</strong>必须一样</li>
<li>路由器总是具有两个或两个以上的IP地址，路由器的每一个接口都有一个不同网络号的IP地址</li>
<li>两个路由器直接相连的接口处，可指明也可不指名IP地址。如指明IP地址，则这一段连线就构成了一种只包含一段线路的特殊网络，现在常不指名IP地址</li>
</ul>
<h3 id="IP地址与硬件地址"><a href="#IP地址与硬件地址" class="headerlink" title="IP地址与硬件地址"></a>IP地址与硬件地址</h3><p>比较重要的一点是要区别IP地址与<strong>硬件地址</strong>的区别<br><img src="http://upload-images.jianshu.io/upload_images/1213532-e502836b70e08031.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IP地址与硬件地址.png"></p>
<p>从层次的角度来看，<strong>物理地址是数据链路层和物理层使用的地址，而IP地址是网络层和以上使用的地址，是一种逻辑地址（称IP地址是逻辑地址是因为IP地址是用 软件实现的）</strong> </p>
<h4 id="从不同层次上来看IP地址和硬件地址"><a href="#从不同层次上来看IP地址和硬件地址" class="headerlink" title="从不同层次上来看IP地址和硬件地址"></a>从不同层次上来看IP地址和硬件地址</h4><p><img src="http://upload-images.jianshu.io/upload_images/1213532-218e10dbc7b37e16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网络配置.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-b619c78d81dc98a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h3 id="需要注意一下几点"><a href="#需要注意一下几点" class="headerlink" title="需要注意一下几点"></a>需要注意一下几点</h3><ul>
<li>在IP层抽象的互联网上只能看见IP数据报</li>
<li>虽然在IP数据报首部有源站IP地址，但<strong>路由器只根据目的站的IP地址的网络号进行路由选择</strong></li>
<li>在具体的物理网络的链路层只能看见MAC帧而看不见IP数据报</li>
<li>IP层抽象的互联网屏蔽了下面很复杂的细节。只要我们在网络层上讨论问题，就能使用统一的、抽象的IP地址研究主机和主机或路由器之间的通信</li>
</ul>
<h2 id="地址解析协议"><a href="#地址解析协议" class="headerlink" title="地址解析协议"></a>地址解析协议</h2><p><img src="http://upload-images.jianshu.io/upload_images/1213532-75d60b065c378c26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="地址解析协议.png"></p>
<ul>
<li>不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用<strong>硬件地址</strong>。 </li>
<li>每一个主机都设有一个 ARP 高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。</li>
<li>当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。  </li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-89f010aaa929bba9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主机A广播发送ARP请求分组.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-6f3398688093884c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主机B向A发送ARP响应分组.png"></p>
<h4 id="ARP高速缓存的作用"><a href="#ARP高速缓存的作用" class="headerlink" title="ARP高速缓存的作用"></a>ARP高速缓存的作用</h4><ul>
<li>为了减少网络上的通信量，主机 A 在发送其 ARP 请求分组时，就将自己的 IP 地址到硬件地址的映射写入 ARP 请求分组。</li>
<li>当主机 B 收到 A 的 ARP 请求分组时，就将主机 A 的这一地址映射写入主机 B 自己的 ARP 高速缓存中。这对主机 B 以后向 A 发送数据报时就更方便了</li>
</ul>
<h4 id="ARP应当注意的是"><a href="#ARP应当注意的是" class="headerlink" title="ARP应当注意的是"></a>ARP应当注意的是</h4><ul>
<li>ARP 是解决同一个局域网上的主机或路由器的 IP 地址和硬件<strong>地址的映射</strong>问题。</li>
<li>如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。</li>
<li>从<strong>IP地址</strong>到<strong>硬件地址</strong>的解析是自动进行的，主机的用户对这种地址解析过程是不知道的。</li>
<li>只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信，ARP协议就会自动地将该 IP 地址解析为链路层所需要的硬件地址。  </li>
</ul>
<h4 id="使用ARP的四种典型情况"><a href="#使用ARP的四种典型情况" class="headerlink" title="使用ARP的四种典型情况"></a>使用ARP的四种典型情况</h4><ul>
<li>发送方是主机，要把IP数据报发送到本网络上的另一个主机。这时用ARP找到目的主机的硬件地址。 </li>
<li>发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用ARP找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。 </li>
<li>发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用ARP找到目的主机的硬件地址。 </li>
<li>发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用ARP 找到本网络上另一个路由器的硬件地址。剩下的工作由这个路由器来完成。 </li>
</ul>
<h4 id="为什么我们不直接使用硬件地址进行通信"><a href="#为什么我们不直接使用硬件地址进行通信" class="headerlink" title="为什么我们不直接使用硬件地址进行通信"></a>为什么我们不直接使用硬件地址进行通信</h4><ul>
<li>由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要使这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作，因此几乎是不可能的事。</li>
<li>连接到因特网的主机都拥有统一的 IP 地址，它们之间的通信就像连接在同一个网络上那样简单方便，因为调用 ARP 来寻找某个路由器或主机的硬件地址都是由计算机软件自动进行的，对用户来说是看不见这种调用过程的。  </li>
</ul>
<h2 id="IP数据报的格式"><a href="#IP数据报的格式" class="headerlink" title="IP数据报的格式"></a>IP数据报的格式</h2><p><img src="http://upload-images.jianshu.io/upload_images/1213532-ab3ff1b55e13a455.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IP数据报的格式.png"></p>
<h3 id="各字段"><a href="#各字段" class="headerlink" title="各字段"></a>各字段</h3><ul>
<li><p>版本 - 占4位，指IP协议的版本（IPv4）</p>
</li>
<li><p>首部长度 - 占4位，可表示的最大十进制数值是15。请注意，首部长度字段所表示数的单位是32位字（一个32位字长是4字节）。因此长度字段的最小值是5（二进制的0101），相当于IP首部长度为5<em>4 = 20字节，而当首部长度为1111时（即十进制的15），首部长度就达到最大值15个32位字长，即60字节。当IP数据报的数据部分永远在4字节的整数倍时开始，这样在实现IP协议时较为方便。首部长度限制为60字节的缺点是有时可能不够用，但这样做是为了尽量减少开销。最常用的首部长度就是20字节（0101）这时不使用任何选项。（</em>然而并没有介绍它是干啥的*）</p>
</li>
<li><p>区分服务 - 占8位，用来获得更好的服务，在旧标准中叫做<strong>服务类型</strong>，但实际上<strong>一直未被使用过</strong>。1998年这个字段改名为区分服务。只有在使用区分服务（DiffServ）时，这个字段才起作用。在一般情况下都不使用这个字段</p>
</li>
<li><p>总长度 - 占16位，指首部和数据之和的长度，单位为字节，因此数据报的最大长度为65535字节。总长度必须不超过最大传送单元MTU。</p>
</li>
<li><p>标识（identification） - 占16位，它是一个计数器，用来产生数据报的标识</p>
</li>
<li><p>标志（flag） - 占3位，目前只有前两位有意义，标志字段的最低位是MF（More Fragment）。MF = 1 表示后面<strong>还有分片</strong>。MF = 0表示最后一个分片标志字段中间的一位是DF(Don’t Fragment)。只有当DF = 0时才允许分片。</p>
</li>
<li><p>片偏移（13位）指出：较长的分组在分片后某片在原分组中的相对位置。<strong>片偏移以8个字节为偏移单位</strong>。<br><strong>IP数据报分片</strong><br><img src="http://upload-images.jianshu.io/upload_images/1213532-cb7cd276e354ad97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IP数据报分片.png"></p>
</li>
<li><p>生存时间（8位）记为TTL（Time To Live）数据报在网络中可通过路由数的最大值</p>
</li>
<li><p>协议（8位）字段指出此数据报携带的数据使用何种协议以便目的主机的IP层将数据部分上交给哪个处理过程<br><img src="http://upload-images.jianshu.io/upload_images/1213532-fd8dbce62a89b6dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="协议字段指明应该将数据交给哪一个进程.png"></p>
</li>
<li><p>首部检验和（16位）字段<strong>只检验数据报的首部不检验数据部分</strong>，这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（<strong>一些字段，如生存时间，标志，片偏移等都可能发生变化</strong>），不检验数据部分可以减少计算的工作量，为了进一步减少计算检验和的工作量，<strong>这里不采用CRC检验码而采用简单的计算方法</strong>：在发送方，先把IP数据报首部划分为许多16位字的序列，并把检验和字段置零。用反码算术运算把所有16位字相加后，将得到的和的反码写入检验和字段。接收方收到数据报后，将首部所有16位字再使用反码算术运算相加一次。将得到的和取反码，即得出接收方检验和的计算结果。若首部未发生任何变化，则此结果必为0，于是就保留这个数据报。否则即认为出差错，并将此数据报丢弃，详情见下图片：<br><img src="http://upload-images.jianshu.io/upload_images/1213532-9eff226430ab56d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" 首部检验和.png"></p>
</li>
<li><p>源地址/目的地址 各占32位</p>
</li>
</ul>
<h3 id="IP数据报首部的可变部分"><a href="#IP数据报首部的可变部分" class="headerlink" title="IP数据报首部的可变部分"></a>IP数据报首部的可变部分</h3><ul>
<li>IP首部的可变部分就是一个选项字段，用来支持排错、测量及安全等措施，内容很丰富</li>
<li>选项字段的长度可变，从1个字节到40个字节不等，取决于所选择的项目</li>
<li>增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。</li>
<li>实际上这些选项很少被使用。</li>
</ul>
<h3 id="IP数据报转发分组的流程"><a href="#IP数据报转发分组的流程" class="headerlink" title="IP数据报转发分组的流程"></a>IP数据报转发分组的流程</h3><p>有<strong>四个A类网络</strong>通过三个路由器连接在一起，每个网络上都可能有成千上万个主机。可以想象，若按目的主机号来制作路由表，则所得出的路由表就会过于庞大。丹若按主机所在的<strong>网络地址</strong>来制作路由表，那么每一个路由器中的路由表就只包含<strong>四个项目</strong>。这样可以大大简化路由表。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-539fc159ae4bc90a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IP数据报转发分组.png"></p>
<p>使用这样的简化图，我们可以不用关心某个网络内部的具体拓扑结构及连接在该网络上有多少台计算机，他还强调了在互联网上转发分组时，是<strong>从一个路由器转发到下一个路由器</strong>。</p>
<h4 id="查找路由表"><a href="#查找路由表" class="headerlink" title="查找路由表"></a>查找路由表</h4><p>根据目的网络地址就能确定下一跳路由器，这一点做的结果是：</p>
<ul>
<li>IP数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的间接交付）</li>
<li>只有到达最后一个路由器时，才试图向目的主机进行交付</li>
</ul>
<h4 id="特定主机路由器"><a href="#特定主机路由器" class="headerlink" title="特定主机路由器"></a>特定主机路由器</h4><p>虽然因特网所有分组转发都是<strong>基于目的主机所在的网络</strong>，但在大多数情况下都允许有这样的特例，即对特定的目的主机指明一个路由。这种路由叫做<strong>特定主机路由</strong>，采用特定主机路由可使网络管理人员能更方便地控制网络和测试网络，同时也可在需要考虑某种安全问题时采用这种特定主机路由。 </p>
<h4 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h4><ul>
<li>路由器还可采用默认路由以减少路由表所占用的空间和搜索路由表所用的时间。</li>
<li>这种转发方式在一个网络<strong>只有很少的对外连接时</strong>是很有用的。</li>
<li>默认路由在主机发送 IP 数据报时往往更能显示出它的好处。</li>
<li>如果一个主机连接在一个小网络上，而这个网络只用一个路由器和因特网连接，那么在这种情况下使用默认路由是非常合适的。 </li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-6832d4d45e5fd5f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="默认路由.png"></p>
<h4 id="必须强调指出"><a href="#必须强调指出" class="headerlink" title="必须强调指出"></a>必须强调指出</h4><p>IP 数据报的首部中<strong>没有地方</strong>可以用来指明“下一跳路由器的 IP 地址”，当路由器收到待转发的数据报，<strong>不是</strong>将下一跳路由器的 IP 地址填入 IP 数据报，而是<strong>送交下层的网络接口软件</strong>。网络接口软件使用 ARP 负责将下一跳路由器的 <strong>IP</strong> 地址转换成<strong>硬件地址</strong>，并将此硬件地址放在链路层的<strong> MAC 帧</strong>的首部，然后根据这个<strong>硬件地址</strong>找到下一跳路由器。  </p>
<h3 id="分组转发算法"><a href="#分组转发算法" class="headerlink" title="分组转发算法"></a>分组转发算法</h3><p>(1)  从数据报的首部提取目的主机的 IP 地址 D, 得出目的网络地址为 N。<br>(2)  若网络 N 与此路由器直接相连，则把数据报直接交付目的主机 D；否则是间接交付，执行(3)。<br>(3)  若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4)。<br>(4)  若路由表中有到达网络 N 的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行(5)。<br>(5) 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行(6)。<br>(6)  报告转发分组出错。 </p>
<h2 id="划分子网和构成超网"><a href="#划分子网和构成超网" class="headerlink" title="划分子网和构成超网"></a>划分子网和构成超网</h2><h3 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h3><h4 id="从两级IP地址到三级IP地址"><a href="#从两级IP地址到三级IP地址" class="headerlink" title="从两级IP地址到三级IP地址"></a>从两级IP地址到三级IP地址</h4><p>在 ARPANET 的早期，IP 地址的设计确实不够合理。</p>
<ul>
<li>IP 地址空间的<strong>利用率</strong>有时很低。 </li>
<li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。 </li>
<li>两级的 IP 地址不够灵活。  </li>
</ul>
<h4 id="三级IP地址"><a href="#三级IP地址" class="headerlink" title="三级IP地址"></a>三级IP地址</h4><p>从 1985 年起在 IP 地址中又增加了一个“子网号字段”，使两级的 IP 地址变成为三级的 IP 地址。这种做法叫作划分子网(subnetting) 。划分子网已成为因特网的正式标准协议。 </p>
<h4 id="划分子网的基本思路"><a href="#划分子网的基本思路" class="headerlink" title="划分子网的基本思路"></a>划分子网的基本思路</h4><ul>
<li>划分子网纯属一个<strong>单位内部的事情</strong>。单位对外仍然<strong>表现为没有划分子网的网络</strong>。</li>
<li>从<strong>主机号</strong>借用若干个位作为<strong>子网号</strong> subnet-id，而主机号 host-id 也就相应减少了若干个位。</li>
<li>凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的<strong>目的网络号</strong> net-id，先找到连接在<strong>本单位网络上的路由器</strong>。</li>
<li>然后此<strong>路由器</strong>在收到 IP 数据报后，再按目的网络号 net-id 和子网号 subnet-id 找到目的子网。</li>
<li>最后就将 IP 数据报直接交付目的主机。 </li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-e2d953ed36119186.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="划分子网.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-1c6a7ebb5526cd1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一个为划分子网的B类网络.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-b7b273c931ef6c47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="划分为三个子网后对外仍是一个网络.png"></p>
<h4 id="划分子网后变成了三级结构"><a href="#划分子网后变成了三级结构" class="headerlink" title="划分子网后变成了三级结构"></a>划分子网后变成了三级结构</h4><ul>
<li>当没有划分子网时，IP 地址是两级结构。</li>
<li>划分子网后 IP 地址就变成了<strong>三级结构</strong>。</li>
<li>划分子网只是把 IP 地址的<strong>主机号</strong> host-id 这部分进行再划分，而<strong>不改变</strong> IP 地址原来的<strong>网络号</strong> net-id。 </li>
</ul>
<h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><ul>
<li>从一个 IP 数据报的首部并<strong>无法判断</strong>源主机或目的主机所连接的网络是否进行了子网划分。</li>
<li>使用<strong>子网掩码</strong>(subnet mask)可以找出 IP 地址中的子网部分。  </li>
</ul>
<h3 id="IP地址的各字段和子网掩码"><a href="#IP地址的各字段和子网掩码" class="headerlink" title="IP地址的各字段和子网掩码"></a>IP地址的各字段和子网掩码</h3><p><img src="http://upload-images.jianshu.io/upload_images/1213532-0ed12b4b26c52c37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IP地址的各字段和子网掩码.png"></p>
<p>请注意现在子网号为3的网络的<strong>网络地址</strong>是145.13.3.0（既不是原来两级的IP地址的网络地址145.13.0.0，也不是简单的子网号3），为了使路由器能很方便的从数据报中的目的IP地址中提取所要找的子网的网络地址，路由器就要使用三级IP地址的子网掩码（如上图，三级IP地址的子网掩码），它也是32位，由一串1和跟随的一串0组成。子网掩码中的1对应于IP地址中原来二级地址中的16位网络号加上新增加的8位子网号，而子网掩码中的0对应于现在的8位主机号。<strong>虽然RFC文档中没有规定子网掩码中的一串1必须是连续的，但却极力推荐在子网掩码中选用连续的1，以避免发生错误</strong></p>
<h3 id="IP地址-AND-子网掩码-网络地址"><a href="#IP地址-AND-子网掩码-网络地址" class="headerlink" title="IP地址 AND 子网掩码 = 网络地址"></a>IP地址 AND 子网掩码 = 网络地址</h3><p>不管有没有划分子网，只要把子网掩码和IP地址进行逐位相<strong>与</strong>运算，就立即得出网络地址来，这样路由器处理到来的分组时可以采用相同的算法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-7228c102e692d20e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IP地址 AND 子网掩码 = 网络地址.png"></p>
<p><strong>归纳下上述的要点，从网络145.13.0.0外面看，这就是一个普通的B类网络，但进入这个网络后（即到了路由器），就看到了还有许多网络（即划分了子网后的许多网络），其网络地址为145.13.x.0（这里x可以表示不同的数值），而这些网络的子网掩码都是24个连1跟上8个连0。总之，在这个网络的内外，看到的网络是不同的</strong></p>
<p><strong>为了更便于查路由表，现在因特网的标准规定：所有的网络都必须使用子网掩码，同时在路由器的路由表中也必须有子网掩码这一栏。如果一个网络不划分子网，那么该网络的子网掩码就使用默认子网掩码，默认子网掩码中1的位置和IP地址中的网络号字段正好相对应。因此，若用默认子网掩码和某个不划分子网的IP地址逐位相与，就应当能够得出该IP地址的网络地址来，这样做可以不用查找该地址的类别位就能知道这是哪一类的IP地址</strong> （书上原话 没懂 ！！！！）</p>
<h3 id="默认子网掩码"><a href="#默认子网掩码" class="headerlink" title="默认子网掩码"></a>默认子网掩码</h3><p><img src="http://upload-images.jianshu.io/upload_images/1213532-ac21dd2611b7dff8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="默认子网掩码.png"></p>
<h3 id="子网掩码是一个重要属性"><a href="#子网掩码是一个重要属性" class="headerlink" title="子网掩码是一个重要属性"></a>子网掩码是一个重要属性</h3><ul>
<li>子网掩码是一个网络或一个子网的重要属性。</li>
<li>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。</li>
<li>路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。</li>
<li>若一个路由器连接在两个子网上就拥有两个网络地址和两个子网掩码。</li>
</ul>
<p><strong>P137有一个表格写B类子网划分选择（使用固定长度子网）</strong></p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="http://upload-images.jianshu.io/upload_images/1213532-e168422c3bb94b41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="例题.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-6cbed066e41184e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="例题.png"></p>
<h3 id="使用子网掩码的分组转发过程"><a href="#使用子网掩码的分组转发过程" class="headerlink" title="使用子网掩码的分组转发过程"></a>使用子网掩码的分组转发过程</h3><ul>
<li>在不划分子网的两级 IP 地址下，从 IP 地址得出网络地址是个很简单的事。</li>
<li>但在划分子网的情况下，从 IP 地址却不能唯一地得出网络地址来，这是因为网络地址取决于那个网络所采用的子网掩码，但数据报的首部并没有提供子网掩码的信息。</li>
<li>因此分组转发的算法也必须做相应的改动。 </li>
</ul>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p><img src="http://upload-images.jianshu.io/upload_images/1213532-765a0c73b51a1afa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用子网掩码的分组转发过程.png"></p>
<p><strong>有一个例题请见教材P139</strong></p>
<h2 id="无分类编址CIDR（无分类域间路由选择）"><a href="#无分类编址CIDR（无分类域间路由选择）" class="headerlink" title="无分类编址CIDR（无分类域间路由选择）"></a>无分类编址CIDR（无分类域间路由选择）</h2><h3 id="网络前缀"><a href="#网络前缀" class="headerlink" title="网络前缀"></a>网络前缀</h3><p>划分子网在一定程度上缓解了因特网在发展中遇到的困难。然而在 1992 年因特网仍然面临三个必须尽早解决的问题，这就是：</p>
<ul>
<li>B 类地址在 1992 年已分配了近一半，眼看就要在 1994 年 3 月全部分配完毕！</li>
<li>因特网主干网上的路由表中的项目数急剧增长（从几千个增长到几万个）。</li>
<li>整个 IPv4 的地址空间最终将全部耗尽。</li>
</ul>
<h2 id="IP地址问题的演进"><a href="#IP地址问题的演进" class="headerlink" title="IP地址问题的演进"></a>IP地址问题的演进</h2><ul>
<li>1987 年，RFC 1009 就指明了在一个划分子网的网络中可同时使用几个不同的子网掩码。使用<strong>变长子网掩码 VLSM </strong>(Variable Length Subnet Mask)可进一步提高 IP 地址资源的利用率。</li>
<li>在 VLSM 的基础上又进一步研究出无分类编址方法，它的正式名字是<strong>无分类域间路由选择 CIDR</strong> (Classless Inter-Domain Routing)。  </li>
</ul>
<h2 id="CIDR最主要的特点"><a href="#CIDR最主要的特点" class="headerlink" title="CIDR最主要的特点"></a>CIDR最主要的特点</h2><ul>
<li>CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间。</li>
<li>CIDR使用各种长度的<strong>网络前缀</strong>(network-prefix)来代替分类地址中的网络号和子网号。</li>
<li>IP 地址从三级编址（使用子网掩码）又回到了两级编址。  </li>
</ul>
<h2 id="无分类的两级编址"><a href="#无分类的两级编址" class="headerlink" title="无分类的两级编址"></a>无分类的两级编址</h2><p>无分类的两级编址的记法是：<br><img src="http://upload-images.jianshu.io/upload_images/1213532-d5194ff3e6318c26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="无分类的两级编址.png"></p>
<p>CIDR 还使用<strong>斜线记法</strong>(slash notation)，它又称为<strong>CIDR记法</strong>，即在 IP 地址后面加上一个斜线“/”，然后写上网络前缀所占的位数（这个数值对应于三级编址中子网掩码中 1 的个数）。CIDR 把网络前缀都相同的连续的 IP 地址组成<strong>“CIDR 地址块”</strong>。  </p>
<p><strong>为了更方便的进行路由选择，CIDR使用32位的地址掩码，地址掩码由一串1和一串0组成，而1的个数就是网络前缀的长度。例如/20地址块的地址掩码是：11111111 11111111 11110000 00000000 20个连续的1，斜线记法中，斜线后面的数字就是地址掩码中1的个数</strong></p>
<h2 id="CIDR地址块"><a href="#CIDR地址块" class="headerlink" title="CIDR地址块"></a>CIDR地址块</h2><ul>
<li>128.14.32.0/20 表示的地址块共有 2^12 个地址（因为<strong>斜线后面的 20 是网络前缀的位数</strong>，所以这个地址的主机号是 12 位[一共32位]）。</li>
<li>这个地址块的起始地址是 128.14.32.0。</li>
<li>在不需要指出地址块的起始地址时，也可将这样的地址块简称为<strong>“/20 地址块”</strong>。</li>
<li>128.14.32.0/20 地址块的最小地址：128.14.32.0</li>
<li>128.14.32.0/20 地址块的最大地址：128.14.47.255</li>
<li>全 0 和全 1 的主机号地址一般不使用。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-b14f42546ea5cdbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CIDR地址块.png"></p>
<h2 id="路由聚合（route-aggregation）"><a href="#路由聚合（route-aggregation）" class="headerlink" title="路由聚合（route aggregation）"></a>路由聚合（route aggregation）</h2><ul>
<li>一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为<strong>路由聚合</strong>，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由。</li>
<li>路由聚合也称为<strong>构成超网</strong>(supernetting)。</li>
<li>CIDR 虽然不使用子网了，但仍然使用<strong>“掩码”</strong>这一名词。</li>
<li>对于 /20  地址块，它的掩码是 20 个连续的 1。 斜线记法中的数字就是掩码中1的个数。    </li>
</ul>
<h2 id="CIDR记法的其他形式"><a href="#CIDR记法的其他形式" class="headerlink" title="CIDR记法的其他形式"></a>CIDR记法的其他形式</h2><p><img src="http://upload-images.jianshu.io/upload_images/1213532-feea1f185820e25f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CIDR记法的其他形式01.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-eee74afdaa9ca34c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CIDR记法的其他形式02.png"></p>
<h2 id="构成超网"><a href="#构成超网" class="headerlink" title="构成超网"></a>构成超网</h2><ul>
<li>前缀长度不超过 23 位的 CIDR 地址块都包含了多个 C 类地址。</li>
<li>这些 C 类地址合起来就构成了超网。</li>
<li>CIDR 地址块中的地址数一定是 2 的整数次幂。</li>
<li>网络前缀越短，其地址块所包含的地址数就越多。而在三级结构的IP地址中，划分子网是使网络前缀变长。  </li>
</ul>
<h2 id="CIDR地址块划分举例"><a href="#CIDR地址块划分举例" class="headerlink" title="CIDR地址块划分举例"></a>CIDR地址块划分举例</h2><p><img src="http://upload-images.jianshu.io/upload_images/1213532-b9c80d1bfd85bc7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CIDR地址块划分举例.png"></p>
<p>这个 ISP 共有 64 个 C 类网络。如果不采用 CIDR 技术，则在与该 ISP 的路由器交换路由信息的每一个路由器的路由表中，就需要有 64 个项目。但采用地址聚合后，只需用路由聚合后的 1 个项目 206.0.64.0/18 就能找到该 ISP。</p>
<p><strong>// 这里还没太懂…. 就是共有多少个几类网络那里</strong></p>
<h2 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h2><ul>
<li>使用 CIDR 时，路由表中的每个项目由“网络前缀”和“下一跳地址”组成。在查找路由表时可能会得到不止一个匹配结果。 </li>
<li>应当从匹配结果中选择具有最长网络前缀的路由：<strong>最长前缀匹配</strong>(longest-prefix matching)。</li>
<li>网络前缀越长，其地址块就越小，因而路由就越具体(more specific) 。</li>
<li>最长前缀匹配又称为<strong>最长匹配</strong>或<strong>最佳匹配</strong>。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-42e6f030c5787b17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="最长前缀匹配举例01.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-888e1fdeba44a278.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="最长前缀匹配举例02.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-fe203efb58346277.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择最长前缀的地址.png"></p>
<h2 id="使用二叉线索树查找路由表"><a href="#使用二叉线索树查找路由表" class="headerlink" title="使用二叉线索树查找路由表"></a>使用二叉线索树查找路由表</h2><ul>
<li>当路由表的项目数很大时，怎样设法减小路由表的查找时间就成为一个非常重要的问题。 </li>
<li>为了进行更加有效的查找，通常是将无分类编址的路由表存放在一种层次的数据结构中，然后自上而下地按层次进行查找。这里最常用的就是<strong>二叉线索(binary trie)。</strong></li>
<li>IP 地址中从左到右的比特值决定了从根结点逐层向下层延伸的路径，而二叉线索中的各个路径就代表路由表中存放的各个地址。</li>
<li>为了提高二叉线索的查找速度，广泛使用了各种压缩技术。   </li>
</ul>
<h3 id="用5个前缀构成的二叉线索"><a href="#用5个前缀构成的二叉线索" class="headerlink" title="用5个前缀构成的二叉线索"></a>用5个前缀构成的二叉线索</h3><p><img src="http://upload-images.jianshu.io/upload_images/1213532-5b99116afbf6c816.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5个前缀构成的二叉线索.png"><br>所谓唯一前缀就是在表中所有的IP地址中，该前缀是唯一的，这样就可以用这些唯一前缀来构造二叉线索，在进行查找时只要能够和唯一前缀相匹配就行了。<br><strong>从上至下来查找</strong></p>
<h2 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h2><ul>
<li>为了提高 IP 数据报交付成功的机会，在网际层使用了网际控制报文协议 ICMP (Internet Control Message Protocol)。</li>
<li>ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。</li>
<li>ICMP 不是高层协议，而是 IP 层的协议。</li>
<li>ICMP 报文作为<strong> IP 层数据报</strong>的数据，加上数据报的首部，组成 IP 数据报发送出去。   </li>
</ul>
<p><strong>报文格式</strong><br><img src="http://upload-images.jianshu.io/upload_images/1213532-a9ca2d3d01db7a2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="报文格式.png"></p>
<h3 id="ICMP报文的种类"><a href="#ICMP报文的种类" class="headerlink" title="ICMP报文的种类"></a>ICMP报文的种类</h3><ul>
<li>ICMP 报文的种类有两种，即 ICMP <strong>差错报告</strong>报文和 ICMP <strong>询问报文</strong>。 </li>
<li>ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即<strong>类型</strong>、<strong>代码</strong>和<strong>检验和</strong>。接着的 4 个字节的内容与 ICMP 的类型有关。</li>
</ul>
<h3 id="ICMP差错报告报文共有5种"><a href="#ICMP差错报告报文共有5种" class="headerlink" title="ICMP差错报告报文共有5种"></a>ICMP差错报告报文共有5种</h3><ul>
<li>终点不可达<br>当路由器或主机不能交付数据报时就向源点发送终点不可达报文</li>
<li>源点抑制(Source quench)<br>当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢</li>
<li>时间超过<br>当路由器收到生存时间为0的数据报时，除了丢弃该数据报外，还要向源点发送时间超过报文，当终点在预定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文</li>
<li>参数问题<br>当路由器或目的主机收到的数据报首部有的字段的值不正确时，就丢弃该数据报，并向源点发送时间超过报文</li>
<li>改变路由（重定向）(Redirect)<br>路由器把改变路由报文发送给主机，让主机知道下次应该将数据报发送给另外的路由器（可通过更好的路由）</li>
</ul>
<p><strong>ICMP差错报告报文的数据字段的内容</strong><br><img src="http://upload-images.jianshu.io/upload_images/1213532-6672375eab46dc55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ICMP差错.png"></p>
<h3 id="不应发送ICMP差错报文的几种情况"><a href="#不应发送ICMP差错报文的几种情况" class="headerlink" title="不应发送ICMP差错报文的几种情况"></a>不应发送ICMP差错报文的几种情况</h3><ul>
<li>对 ICMP 差错报告报文不再发送 ICMP 差错报告报文。</li>
<li>对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文。</li>
<li>对具有多播地址的数据报都不发送 ICMP 差错报告报文。</li>
<li>对具有特殊地址（如127.0.0.0 或 0.0.0.0）的数据报不发送 ICMP 差错报告报文。</li>
</ul>
<h3 id="ICMP询问报文"><a href="#ICMP询问报文" class="headerlink" title="ICMP询问报文"></a>ICMP询问报文</h3><ul>
<li>回送请求和回答<br>ICMP回送请求报文使由主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机发送ICMP回送回答报文。这种询问报文用来测试目的站是否可达以及了解其有关状态</li>
<li>时间戳请求和回答<br>ICMP时间戳请求报文是请求某个主机或路由器回答当前的日期和时间。在ICMP时间戳回答报文中有一个32位的字段，其中写入的整数代表从1900年1月1日起到当时是哪一共有多少秒，时间戳请求与回答可用来进行时钟同步和测量时间。</li>
</ul>
<h3 id="ICMP的应用举例"><a href="#ICMP的应用举例" class="headerlink" title="ICMP的应用举例"></a>ICMP的应用举例</h3><ul>
<li>PING 用来测试两个主机之间的连通性。</li>
<li>PING 使用了 ICMP 回送请求与回送回答报文。</li>
<li>PING 是应用层直接使用网络层 ICMP 的例子，它没有通过<strong>运输层</strong>的 TCP 或UDP。 </li>
</ul>
<p>具体命令行命令见 P149</p>
<h2 id="因特网的路由选择协议"><a href="#因特网的路由选择协议" class="headerlink" title="因特网的路由选择协议"></a>因特网的路由选择协议</h2><h3 id="有关路由选择协议的几个基本概念"><a href="#有关路由选择协议的几个基本概念" class="headerlink" title="有关路由选择协议的几个基本概念"></a>有关路由选择协议的几个基本概念</h3><h4 id="理想路由算法"><a href="#理想路由算法" class="headerlink" title="理想路由算法"></a>理想路由算法</h4><ul>
<li>算法必须是正确的和完整的。 </li>
<li>算法在计算上应简单。 </li>
<li>算法应能适应通信量和网络拓扑的变化，这就是说，要有<strong>自适应性</strong>。 </li>
<li>算法应具有稳定性。 </li>
<li>算法应是公平的。 </li>
<li>算法应是最佳的。 </li>
</ul>
<h4 id="关于最佳路由"><a href="#关于最佳路由" class="headerlink" title="关于最佳路由"></a>关于最佳路由</h4><ul>
<li>不存在一种绝对的最佳路由算法。</li>
<li>所谓“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已。</li>
<li>实际的路由选择算法，应尽可能接近于理想的算法。 </li>
<li>路由选择是个非常复杂的问题<ul>
<li>它是网络中的所有结点共同协调工作的结果。</li>
<li>路由选择的环境往往是不断变化的，而这种变化有时无法事先知道。  </li>
</ul>
</li>
</ul>
<h4 id="从路由算法的自适应性考虑"><a href="#从路由算法的自适应性考虑" class="headerlink" title="从路由算法的自适应性考虑"></a>从路由算法的自适应性考虑</h4><ul>
<li><strong>静态</strong>路由选择策略——即非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。 </li>
<li><strong>动态</strong>路由选择策略——即自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。  </li>
</ul>
<h4 id="分层次的路由选择协议"><a href="#分层次的路由选择协议" class="headerlink" title="分层次的路由选择协议"></a>分层次的路由选择协议</h4><ul>
<li>因特网采用分层次的路由选择协议。</li>
<li>因特网的规模非常大。如果让所有的路由器知道所有的网络应怎样到达，则这种路由表将非常大，处理起来也太花时间。而所有这些路由器之间交换路由信息所需的带宽就会使因特网的通信链路饱和。</li>
<li>许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议（这属于本部门内部的事情），但同时还希望连接到因特网上。   </li>
</ul>
<h4 id="自治系统AS（Autonomous-System）"><a href="#自治系统AS（Autonomous-System）" class="headerlink" title="自治系统AS（Autonomous System）"></a>自治系统AS（Autonomous System）</h4><ul>
<li>自治系统 AS 的定义：在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS之间的路由。</li>
<li>现在对自治系统 AS 的定义是强调下面的事实：尽管一个 AS 使用了多种内部路由选择协议和度量，但重要的是一个 AS 对其他 AS 表现出的是一个<strong>单一</strong>的和<strong>一致的路由选择策略</strong>。</li>
</ul>
<h4 id="因特网有两大路由选择协议"><a href="#因特网有两大路由选择协议" class="headerlink" title="因特网有两大路由选择协议"></a>因特网有两大路由选择协议</h4><ul>
<li><strong>内部网关协议</strong> IGP (Interior Gateway Protocol)    即在一个自治系统内部使用的路由选择协议。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。</li>
<li><strong>外部网关协议EGP</strong> (External Gateway Protocol)    若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。在外部网关协议中目前使用最多的是 BGP-4。  </li>
</ul>
<h4 id="自治系统和内部网关协议、外部网关协议"><a href="#自治系统和内部网关协议、外部网关协议" class="headerlink" title="自治系统和内部网关协议、外部网关协议"></a>自治系统和内部网关协议、外部网关协议</h4><p><img src="http://upload-images.jianshu.io/upload_images/1213532-7bce33dc100ab7e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自治系统和内部网关协议、外部网关协议.png"></p>
<h4 id="这里要指出两点"><a href="#这里要指出两点" class="headerlink" title="这里要指出两点"></a>这里要指出两点</h4><ul>
<li>因特网的早期 RFC 文档中未使用“路由器”而是使用“网关”这一名词。但是在新的 RFC 文档中又使用了“路由器”这一名词。应当把这两个属于当作同义词。</li>
<li>IGP 和 EGP 是协议类别的名称。但 RFC 在使用 EGP 这个名词时出现了一点混乱，因为最早的一个外部网关协议的协议名字正好也是 EGP。因此在遇到名词 EGP 时，应弄清它是指旧的协议 EGP 还是指外部网关协议 EGP 这个类别。   </li>
</ul>
<h4 id="因特网的路由选择协议-1"><a href="#因特网的路由选择协议-1" class="headerlink" title="因特网的路由选择协议"></a>因特网的路由选择协议</h4><ul>
<li>内部网关协议 IGP：具体的协议有多种，如 RIP 和 OSPF 等。</li>
<li>外部网关协议 EGP：目前使用的协议就是 BGP。</li>
</ul>
<h3 id="内部网关协议RIP（Routing-Information-Protocol-路由信息协议）"><a href="#内部网关协议RIP（Routing-Information-Protocol-路由信息协议）" class="headerlink" title="内部网关协议RIP（Routing Information Protocol/路由信息协议）"></a>内部网关协议RIP（Routing Information Protocol/路由信息协议）</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul>
<li>路由信息协议 RIP 是内部网关协议 IGP中最先得到广泛使用的协议。</li>
<li>RIP 是一种分布式的基于<strong>距离向量</strong>的路由选择协议。</li>
<li>RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。 </li>
</ul>
<h4 id="距离的定义"><a href="#距离的定义" class="headerlink" title="距离的定义"></a>距离的定义</h4><ul>
<li>从一路由器到<strong>直接连接</strong>的网络的距离定义为 1。</li>
<li>从一个路由器到非直接连接的网络的距离定义为所经过的路由器数加 1。</li>
<li>RIP 协议中的“距离”也称为<strong>“跳数”</strong>(hop count)，因为每经过一个路由器，跳数就加 1。</li>
<li>这里的“距离”实际上指的是<strong>“最短距离”</strong></li>
<li>RIP 认为一个好的路由就是它通过的路由器的数目少，即“距离短”。</li>
<li>RIP 允许一条路径最多只能包含 15 个路由器，“距离”的最大值为16 时即相当于不可达。可见 RIP 只适用于小型互联网。</li>
<li>RIP 不能在两个网络之间同时使用多条路由。RIP 选择一个具有最少路由器的路由（即最短路由），哪怕还存在另一条高速(低时延)但路由器较多的路由。   </li>
</ul>
<h4 id="RIP协议的三个要点"><a href="#RIP协议的三个要点" class="headerlink" title="RIP协议的三个要点"></a>RIP协议的三个要点</h4><ul>
<li>仅和<strong>相邻路由器</strong>交换信息。 </li>
<li>交换的信息是当前本路由器所知道的<strong>全部信息</strong>，即自己的<strong>路由表</strong>。 </li>
<li>按固定的时间间隔<strong>交换路由信息</strong>，例如，每隔 30 秒。 </li>
</ul>
<h4 id="路由表的建立"><a href="#路由表的建立" class="headerlink" title="路由表的建立"></a>路由表的建立</h4><ul>
<li>路由器在刚刚开始工作时，只知道到直接连接的网络的距离（此距离定义为1）。</li>
<li>以后，每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。</li>
<li>经过若干次更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。</li>
<li>RIP 协议的<strong>收敛</strong>(convergence)过程较快，即在自治系统中所有的结点都得到正确的路由选择信息的过程。 </li>
</ul>
<h4 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h4><p><img src="http://upload-images.jianshu.io/upload_images/1213532-69ec4054461586e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="距离向量算法.png"></p>
<p><strong>P154有一道例题</strong></p>
<h4 id="路由器之间交换信息"><a href="#路由器之间交换信息" class="headerlink" title="路由器之间交换信息"></a>路由器之间交换信息</h4><ul>
<li>RIP协议让互联网中的所有路由器都和自己的相邻路由器不断交换路由信息，并不断更新其路由表，使得从每一个路由器到每一个目的网络的路由都是最短的（即跳数最少）。</li>
<li>虽然所有的路由器最终都拥有了整个自治系统的全局路由信息，但由于每一个路由器的位置不同，它们的路由表当然也应当是不同的。</li>
</ul>
<h3 id="RIP2协议的报文格式"><a href="#RIP2协议的报文格式" class="headerlink" title="RIP2协议的报文格式"></a>RIP2协议的报文格式</h3><p><img src="http://upload-images.jianshu.io/upload_images/1213532-b5608da3da722122.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RIP2协议的报文格式.png"></p>
<h4 id="RIP2的报文由首部和路由部分组成"><a href="#RIP2的报文由首部和路由部分组成" class="headerlink" title="RIP2的报文由首部和路由部分组成"></a>RIP2的报文由首部和路由部分组成</h4><ul>
<li>RIP2 报文中的路由部分由若干个路由信息组成。每个路由信息需要用 20 个字节。地址族标识符（又称为地址类别）字段用来标志所使用的地址协议。</li>
<li>路由标记填入自治系统的号码，这是考虑使RIP 有可能收到本自治系统以外的路由选择信息。再后面指出某个网络地址、该网络的子网掩码、下一跳路由器地址以及到此网络的距离。  </li>
</ul>
<h4 id="RIP协议的优缺点"><a href="#RIP协议的优缺点" class="headerlink" title="RIP协议的优缺点"></a>RIP协议的优缺点</h4><ul>
<li>RIP 存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。</li>
<li>RIP 协议最大的优点就是实现简单，开销较小。</li>
<li>RIP <strong>限制了网络的规模</strong>，它能使用的最大距离为 15（16 表示不可达）。<br>路由器之间<strong>交换</strong>的路由信息是路由器中的<strong>完整路由表</strong>，因而随着网络规模的扩大，开销也就增加。   </li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-f47f1bbb1d5c181c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RIP协议的优缺点01.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-76c22edf011865e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RIP协议的优缺点02.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-e7b70cfb28f75281.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RIP协议的优缺点03.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-55d0b14d423cd78a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RIP协议的优缺点04.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-827c05e61d9d966f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RIP协议的优缺点05.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-eb1394082b56b03b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RIP协议的优缺点06.png"></p>
<h2 id="内部网关协议OSPF（Open-Shortest-Path-Frist-开放最短路径优先）"><a href="#内部网关协议OSPF（Open-Shortest-Path-Frist-开放最短路径优先）" class="headerlink" title="内部网关协议OSPF（Open Shortest Path Frist/开放最短路径优先）"></a>内部网关协议OSPF（Open Shortest Path Frist/开放最短路径优先）</h2><p>它是为了克服RIP的缺点在1989年开放出来的</p>
<h3 id="OSPF-协议的基本特点"><a href="#OSPF-协议的基本特点" class="headerlink" title="OSPF 协议的基本特点"></a>OSPF 协议的基本特点</h3><ul>
<li>“开放”表明 OSPF 协议不是受某一家厂商控制，而是公开发表的。</li>
<li>“最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法SPF</li>
<li>OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。</li>
<li>是分布式的<strong>链路状态协议</strong>，而不是像RIP那样的。 </li>
</ul>
<h3 id="三个要点"><a href="#三个要点" class="headerlink" title="三个要点"></a>三个要点</h3><ul>
<li><strong>向本自治系统中所有路由器发送信息</strong>，这里使用的方法是<strong>洪泛法</strong>。</li>
<li>发送的信息就是与本路由器<strong>相邻</strong>的所有路由器的链路状态，但这只是路由器所知道的<strong>部分信息</strong>。<ul>
<li>“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的<strong>“度量”(metric)</strong>。 </li>
</ul>
</li>
<li>只有当链路状态<strong>发生变化</strong>时，路由器才用洪泛法向所有路由器发送此信息。  </li>
</ul>
<h3 id="链路状态数据库"><a href="#链路状态数据库" class="headerlink" title="链路状态数据库"></a>链路状态数据库</h3><ul>
<li>由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库。</li>
<li>这个数据库实际上就是<strong>全网的拓扑结构图</strong>，它在全网范围内是一致的（这称为链路状态数据库的<strong>同步</strong>）。</li>
<li>OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。OSPF 的<strong>更新过程收敛得快</strong>是其重要优点。  </li>
</ul>
<h3 id="OSPF的区域（area）"><a href="#OSPF的区域（area）" class="headerlink" title="OSPF的区域（area）"></a>OSPF的区域（area）</h3><ul>
<li>为了使 OSPF 能够用于规模很大的网络，OSPF 将<strong>一个自治系统</strong>再划分为若干个更小的范围，叫作<strong>区域</strong>。</li>
<li>每一个区域都有一个 32 位的区域标识符（用点分十进制表示）。</li>
<li>区域也不能太大，在一个区域内的路由器最好不超过 200 个。  </li>
</ul>
<h3 id="划分为两种不同区域"><a href="#划分为两种不同区域" class="headerlink" title="划分为两种不同区域"></a>划分为两种不同区域</h3><p><img src="http://upload-images.jianshu.io/upload_images/1213532-2460a50cceba67a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="划分两种不同的区域.png"></p>
<ul>
<li>划分区域的好处就是将利用洪泛法交换链路状态信息的范围局限于<strong>每一个区域</strong>而不是<strong>整个的自治系统</strong>，这就<strong>减少</strong>了整个网络上的通信量。</li>
<li>在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。</li>
<li>OSPF 使用层次结构的区域划分。在上层的区域叫作<strong>主干区域</strong>(backbone area)。主干区域的标识符规定为0.0.0.0。主干区域的作用是用来连通其他在下层的区域。  </li>
</ul>
<p>主干区域的作用是用来连通其他在下层的区域。从其他区域来的信息都由<strong>区域边界路由器</strong>进行概括。上图中<strong>R3，R4，R7</strong>都是区域边界路由器，显然<strong>每一个区域至少有一个区域边界路由器</strong>，在主干区域的路由器叫做<strong>主干路由器</strong>，如<strong>R3，R4，R5，R6，R7</strong>，一个主干路由器可以同时是区域边界路由器，如<strong>R3，R4，R7</strong>，在主干区域还要有一个路由器专门和本自治系统外的其他自治系统交换路由信息。这样的路由器叫做<strong>自治系统边界路由器</strong>（R6）</p>
<h3 id="OSPF直接用IP数据报传送"><a href="#OSPF直接用IP数据报传送" class="headerlink" title="OSPF直接用IP数据报传送"></a>OSPF直接用IP数据报传送</h3><ul>
<li>OSPF 不用 UDP 而是直接用 IP 数据报传送。</li>
<li>OSPF 构成的数据报很短。这样做可减少路由信息的通信量。</li>
<li>数据报很短的另一好处是可以<strong>不必将长的数据报分片传送</strong>。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。 </li>
</ul>
<h3 id="OSPF的其他特点"><a href="#OSPF的其他特点" class="headerlink" title="OSPF的其他特点"></a>OSPF的其他特点</h3><ul>
<li>OSPF 对不同的链路可根据 IP 分组的不同服务类型 TOS 而设置成不同的代价。因此，<strong>OSPF 对于不同类型的业务可计算出不同的路由</strong>。</li>
<li>如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫作多路径间的<strong>负载平衡</strong>。</li>
<li>所有在 OSPF 路由器之间交换的分组都具有<strong>鉴别</strong>的功能，这就保证了仅在可信赖的路由器之间交换链路状态信息。</li>
<li>支持可变长度的子网划分和无分类编址 CIDR。</li>
<li>每一个链路状态都带上一个 32 位的序号，序号越大状态就越新。</li>
</ul>
<h3 id="OSPF分组"><a href="#OSPF分组" class="headerlink" title="OSPF分组"></a>OSPF分组</h3><p><img src="http://upload-images.jianshu.io/upload_images/1213532-79c18af455eadea3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OSPF分组.png"></p>
<ul>
<li><strong>版本</strong>  当前为2</li>
<li><strong>类型</strong>  5种类型分组中的一种</li>
<li><strong>分组长度</strong>  包括OSPF首部在内的分组长度，以字节为单位</li>
<li><strong>路由器标识符</strong>  标志发送该分组的路由器的接口的IP地址</li>
<li><strong>区域标识符</strong>  分组属于的区域的标识符</li>
<li><strong>检验和</strong>  用来检验分组中的差错</li>
<li><strong>鉴别类型</strong>  目前只有两种。0（不用）和1（口令）</li>
<li><strong>鉴别</strong> 鉴别类型为0时就填入0，为1时就填入8个字符的口令</li>
</ul>
<h4 id="OSPF的5种分组类型"><a href="#OSPF的5种分组类型" class="headerlink" title="OSPF的5种分组类型"></a>OSPF的5种分组类型</h4><ul>
<li>类型1，问候(Hello)分组，来发现和维持临站的可达性</li>
<li>类型2，数据库描述(Database Description)分组，向临站给出自己的链路状态数据库中的所有链路状态项目的摘要信息</li>
<li>类型3，链路状态请求(Link State Request)分组，向对方请求发送某些链路状态项目的详细信息</li>
<li>类型4，链路状态更新(Link State Update)分组，用洪泛法对全网更新链路状态</li>
<li>类型5，链路状态确认(Link State Acknowledgment)分组，对链路更新分组的确认</li>
</ul>
<h4 id="OSPF的基本操作"><a href="#OSPF的基本操作" class="headerlink" title="OSPF的基本操作"></a>OSPF的基本操作</h4><p><img src="http://upload-images.jianshu.io/upload_images/1213532-bd3e9359490af994.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OSPF的基本操作.png"></p>
<h4 id="OSPF使用的是可靠的洪泛法"><a href="#OSPF使用的是可靠的洪泛法" class="headerlink" title="OSPF使用的是可靠的洪泛法"></a>OSPF使用的是可靠的洪泛法</h4><p><img src="http://upload-images.jianshu.io/upload_images/1213532-659a5b6307b6bf60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OSPF使用的是可靠的洪泛法.png"></p>
<p>假设路由器R用洪泛法发出链路状态更新分组。图中的一些小箭头表示更新分组。第一次先发给<strong>相邻</strong>的三个路由器。这三个路由器将收到的分组再进行转发时，要将其上游路由器除外。可靠的洪泛法是在收到更新分组后要发送确认（收到重复更新的分组只需发送一次确认，图中蓝绿箭头表示确认分组）</p>
<h4 id="OSPF的其他特点-1"><a href="#OSPF的其他特点-1" class="headerlink" title="OSPF的其他特点"></a>OSPF的其他特点</h4><ul>
<li>OSPF 还规定每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。 </li>
<li>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多。 </li>
<li>OSPF 没有“坏消息传播得慢”的问题，据统计，其响应网络变化的时间小于 100 ms。 </li>
<li>若N个路由器连接在一个以太网上，则每个路由器要向其他N-1个路由器发送链路状态信息，因而共有N (N-1)个链路状态要在这个以太网上传送。OSPF协议对这种多点接入局域网采用了<strong>指定的路由器</strong>的方法，使广播的信息量大大减少。指定的路由器代表该局域网上所有的链路向连接到该网络上的各路由器发送状态信息。 </li>
</ul>
<h2 id="外部网关协议BGP"><a href="#外部网关协议BGP" class="headerlink" title="外部网关协议BGP"></a>外部网关协议BGP</h2><ul>
<li>BGP 是不同自治系统的路由器之间交换路由信息的协议。 </li>
<li>BGP 较新版本是 2006 年 1 月发表的 BGP-4（BGP 第 4 个版本），即 RFC 4271 ~ 4278。 </li>
<li>可以将 BGP-4 简写为 BGP。 </li>
</ul>
<h3 id="BGP使用的环境与内部网关协议不同的原因"><a href="#BGP使用的环境与内部网关协议不同的原因" class="headerlink" title="BGP使用的环境与内部网关协议不同的原因"></a>BGP使用的环境与内部网关协议不同的原因</h3><ul>
<li>因特网的规模太大，使得自治系统之间路由选择非常困难。对于<strong>自治系统之间</strong>的路由选择，要寻找最佳路由是很不现实的。<ul>
<li>当一条路径通过几个不同 AS 时，要想对这样的路径计算出有意义的代价是不太可能的。</li>
<li>比较合理的做法是在 AS 之间交换“可达性”信息。   </li>
</ul>
</li>
<li>自治系统之间的路由选择必须考虑有关策略。</li>
<li>因此，边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且<strong>比较好的路由</strong>（不能兜圈子），而<strong>并非要寻找一条最佳路由</strong>。</li>
</ul>
<h3 id="BGP发言人"><a href="#BGP发言人" class="headerlink" title="BGP发言人"></a>BGP发言人</h3><ul>
<li>每一个自治系统的管理员要选择至少一个路由器作为该自治系统的<strong>“ BGP 发言人” </strong>。</li>
<li>一般说来，两个 BGP 发言人都是通过一个共享网络连接在一起的，而 BGP 发言人往往就是 BGP <strong>边界路由器</strong>，但也可以<strong>不是</strong> BGP 边界路由器。 </li>
</ul>
<h3 id="BGP交换路由信息"><a href="#BGP交换路由信息" class="headerlink" title="BGP交换路由信息"></a>BGP交换路由信息</h3><ul>
<li>一个 BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息，就要先建立 TCP 连接，然后在此连接上交换 BGP 报文以建立 BGP <strong>会话</strong>(session)，利用 BGP 会话交换路由信息。</li>
<li>使用 TCP 连接能提供可靠的服务，也简化了路由选择协议。</li>
<li>使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此成为对方的<strong>邻站</strong>或<strong>对等站</strong>。</li>
</ul>
<h3 id="BGP发言人和自治系统AS的关系"><a href="#BGP发言人和自治系统AS的关系" class="headerlink" title="BGP发言人和自治系统AS的关系"></a>BGP发言人和自治系统AS的关系</h3><p><img src="http://upload-images.jianshu.io/upload_images/1213532-5eab312da45ab271.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="BGP发言人和自治系统AS的关系.png"></p>
<p>每个BGP发言人除了运行BGP协议外，还必须运行自治系统所使用的内部网关协议，如OSPF或RIP。</p>
<h3 id="AS的连通图举例"><a href="#AS的连通图举例" class="headerlink" title="AS的连通图举例"></a>AS的连通图举例</h3><ul>
<li>BGP 所交换的网络可达性的信息就是要到达某个网络所要经过的一系列 AS。</li>
<li>当 BGP 发言人互相交换了网络可达性的信息后，各 BGP 发言人就根据所采用的策略从收到的路由信息中找出到达各 AS 的较好路由。 </li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-b2cc644151459461.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AS的连通图举例.png"><br>它是树形结构不存在回路</p>
<h3 id="BGP发言人交换路径向量"><a href="#BGP发言人交换路径向量" class="headerlink" title="BGP发言人交换路径向量"></a>BGP发言人交换路径向量</h3><p><img src="http://upload-images.jianshu.io/upload_images/1213532-f4313263c28371cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="BGP发言人交换路径向量01.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-e19c660e2b6a709c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="BGP发言人交换路径向量02.png"></p>
<h3 id="BGP协议的特点"><a href="#BGP协议的特点" class="headerlink" title="BGP协议的特点"></a>BGP协议的特点</h3><ul>
<li>BGP 协议交换路由信息的结点数量级是<strong>自治系统数的量级</strong>，这要比这些自治系统中的网络数少很多。</li>
<li>每一个自治系统中 BGP 发言人（或边界路由器）的数目是很少的。这样就使得自治系统之间的路由选择不致过分复杂。  </li>
<li>BGP 支持 CIDR，因此 BGP 的路由表也就应当包括<strong>目的网络前缀</strong>、<strong>下一跳路由器</strong>，以及到达该目的网络所<strong>要经过的各个自治系统序列</strong>。</li>
<li>在BGP <strong>刚刚运行</strong>时，BGP 的邻站是<strong>交换整个的 BGP 路由表</strong>。但以后只需要在发生变化时<strong>更新有变化的部分</strong>。这样做对节省网络带宽和减少路由器的处理开销方面都有好处。 </li>
</ul>
<h3 id="BGP共使用四种报文"><a href="#BGP共使用四种报文" class="headerlink" title="BGP共使用四种报文"></a>BGP共使用四种报文</h3><ul>
<li>打开(OPEN)报文，用来与相邻的另一个BGP发言人建立关系。</li>
<li>更新(UPDATE)报文，用来发送某一路由的信息，以及列出要撤消的多条路由。</li>
<li>保活(KEEPALIVE)报文，用来确认打开报文和周期性地证实邻站关系。</li>
<li>通知(NOTIFICATION)报文，用来发送检测到的差错。</li>
</ul>
<p>在 RFC 2918 中增加了 ROUTE-REFRESH 报文，用来请求对等端重新通告。 </p>
<h3 id="BGP报文具有通用的首部"><a href="#BGP报文具有通用的首部" class="headerlink" title="BGP报文具有通用的首部"></a>BGP报文具有通用的首部</h3><p><img src="http://upload-images.jianshu.io/upload_images/1213532-cd8084d38d200c5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="BGP报文具有通用的首部.png"></p>
<h1 id="路由器在网际互连中的作用"><a href="#路由器在网际互连中的作用" class="headerlink" title="路由器在网际互连中的作用"></a>路由器在网际互连中的作用</h1><h2 id="路由器的结构"><a href="#路由器的结构" class="headerlink" title="路由器的结构"></a>路由器的结构</h2><p>路由器是一种具有多个输入端口和多个输出端口的<strong>专用计算机</strong>，其任务是<strong>转发分组</strong>。也就是说，将路由器某个<strong>输入端口</strong>收到的分组，按照分组要去的目的地（即目的网络），把该分组从路由器的某个合适的<strong>输出端口</strong>转发给<strong>下一跳路由器</strong>。下一跳路由器也按照这种方法处理分组，直到该分组到达终点为止。 </p>
<h2 id="典型的路由器结构"><a href="#典型的路由器结构" class="headerlink" title="典型的路由器结构"></a>典型的路由器结构</h2><p>下图的方框中的1,2,3分别代表物理层，数据链路层和网络层的处理模块<br><img src="http://upload-images.jianshu.io/upload_images/1213532-282252f6a51bfa94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="典型的路由器结构.png"><br>从图中可以看出，整个路由器结构可以划分为两大部分 <strong>路由选择</strong>部分和<strong>分组转发</strong>部分。</p>
<p>路由选择部分也叫作控制部分，其核心构件是路由选择处理机。路由选择处理机的任务是根据所选定的<strong>路由选择协议</strong>（上面的内部/外部…协议）构造出路由表，通常经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表。</p>
<p><strong>分组转发</strong>部分是本节要讨论的问题，它由三部分组成：<strong>交换结构</strong>、一组<strong>输入端口</strong>、一组<strong>输出端口</strong>（这里的端口就指的是硬件接口）</p>
<p>图中的<strong>交换结构</strong>又称为交换组织，它的作用是根据<strong>转发表</strong>对分组进行处理，将某个<strong>输入端口</strong>进入的分组从一个合适的<strong>输出端口</strong>转发出去。交换结构本身就是<strong>一种网络</strong>，但这种网络完全<strong>包含在路由器中</strong>，因此交换网络可看成是<strong>在路由器中的网络</strong></p>
<h3 id="转发和路由器选择的区别"><a href="#转发和路由器选择的区别" class="headerlink" title="转发和路由器选择的区别"></a>转发和路由器选择的区别</h3><ul>
<li><strong>“转发”(forwarding)</strong>就是路由器根据<strong>转发表</strong>将用户的 IP 数据报从合适的端口转发出去，<strong>仅仅涉及到一个路由器</strong>。</li>
<li><strong>“路由选择”(routing)</strong>则是按照分布式算法，根据从各相邻路由器得到的关于网络拓扑的变化情况，动态地改变所选择的路由，<strong>涉及到很多路由器</strong>。</li>
</ul>
<p>路由表是根据路由选择算法得出的。而转发表是从路由表得出的。<br><strong>在讨论路由选择的原理时，往往不去区分转发表和路由表的区别</strong></p>
<h2 id="输入端口对线路上收到的分组的处理"><a href="#输入端口对线路上收到的分组的处理" class="headerlink" title="输入端口对线路上收到的分组的处理"></a>输入端口对线路上收到的分组的处理</h2><p>数据链路层剥去帧首部和尾部后，将分组送到网络层的队列中排队等待处理，这会产生一定的时延<br><img src="http://upload-images.jianshu.io/upload_images/1213532-8e119cb74c9bdf4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输入端口对线路上收到的分组的处理.png"></p>
<p><strong>有一详细的过程请看P167</strong></p>
<h2 id="输出端口将交换结构传送来的分组发送到线路"><a href="#输出端口将交换结构传送来的分组发送到线路" class="headerlink" title="输出端口将交换结构传送来的分组发送到线路"></a>输出端口将交换结构传送来的分组发送到线路</h2><p>当交换结构传送过来的分组先进行缓存。数据链路层处理模块将分组加上链路层的首部和尾部，交给物理层后发送到外部线路。<br><img src="http://upload-images.jianshu.io/upload_images/1213532-e599ef91cf604457.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输出端口将交换结构传送来的分组发送到线路.png"></p>
<h2 id="分组丢弃"><a href="#分组丢弃" class="headerlink" title="分组丢弃"></a>分组丢弃</h2><ul>
<li>若路由器处理分组的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃。</li>
<li>路由器中的输入或输出队列产生<strong>溢出</strong>是造成分组丢失的重要原因。  </li>
</ul>
<h2 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h2><p>交换结构是路由器的关键构件，正是这个交换结构将分组从一个输入端口转移到某个合适的输出端口。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-fdfa61b9e19b989f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="交换结构.png"></p>
<h2 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h2><h3 id="IP多播的基本概念"><a href="#IP多播的基本概念" class="headerlink" title="IP多播的基本概念"></a>IP多播的基本概念</h3><p><img src="http://upload-images.jianshu.io/upload_images/1213532-f43e94cf0b951828.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="不使用多播.png"></p>
<p><strong>多播可以明显地减少网络中资源的消耗</strong><br><img src="http://upload-images.jianshu.io/upload_images/1213532-e735070d1da22151.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多播可以明显地减少网络中资源的消耗.png"></p>
<h3 id="IP多播的一些特点"><a href="#IP多播的一些特点" class="headerlink" title="IP多播的一些特点"></a>IP多播的一些特点</h3><ul>
<li>多播使用组地址—— IP 使用 D 类地址支持多播。多播地址只能用于目的地址，而不能用于源地址。  </li>
<li>永久组地址——由因特网号码指派管理局 IANA 负责指派。</li>
<li>动态的组成员 </li>
<li>使用硬件进行多播</li>
</ul>
<h3 id="在局域网上进行硬件多播"><a href="#在局域网上进行硬件多播" class="headerlink" title="在局域网上进行硬件多播"></a>在局域网上进行硬件多播</h3><ul>
<li>因特网号码指派管理局 IANA 拥有的以太网地址块的高 24 位为 00-00-5E。</li>
<li>因此 TCP/IP 协议使用的以太网多播地址块的范围是：从 00-00-5E-00-00-00到 00-00-5E-FF-FF-FF </li>
<li>D 类 IP 地址可供分配的有 28 位，在这 28 位中的前 5 位不能用来构成以太网硬件地址。</li>
</ul>
<h3 id="D类IP地址与以太网多播地址的映射关系"><a href="#D类IP地址与以太网多播地址的映射关系" class="headerlink" title="D类IP地址与以太网多播地址的映射关系"></a>D类IP地址与以太网多播地址的映射关系</h3><p><strong>有一段介绍P171</strong><br><img src="http://upload-images.jianshu.io/upload_images/1213532-cf8d68d4af575ab5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="D类IP地址与以太网多播地址的映射关系.png"></p>
<h2 id="网际组管理协议IGMP和多播路由选择协议"><a href="#网际组管理协议IGMP和多播路由选择协议" class="headerlink" title="网际组管理协议IGMP和多播路由选择协议"></a>网际组管理协议IGMP和多播路由选择协议</h2><h3 id="IP多播需要两种协议"><a href="#IP多播需要两种协议" class="headerlink" title="IP多播需要两种协议"></a>IP多播需要两种协议</h3><ul>
<li>为了使路由器知道多播组成员的信息，需要利用<strong>网际组管理协议</strong> IGMP (Internet Group Management Protocol)。</li>
<li>连接在局域网上的<strong>多播路由器</strong>还必须和因特网上的其他多播路由器协同工作，以便把多播数据报用最小代价传送给所有的组成员。这就需要使用<strong>多播路由选择协议</strong>。</li>
</ul>
<h3 id="IGMP使多播路由器知道多播组成员信息"><a href="#IGMP使多播路由器知道多播组成员信息" class="headerlink" title="IGMP使多播路由器知道多播组成员信息"></a>IGMP使多播路由器知道多播组成员信息</h3><p><img src="http://upload-images.jianshu.io/upload_images/1213532-25016973ca482cef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IGMP使多播路由器知道多播组成员信息.png"></p>
<p>IGMP的<strong>本地</strong>使用范围</p>
<ul>
<li>IGMP <strong>并非</strong>在因特网范围内对所有多播组成员进行管理的协议。</li>
<li>IGMP <strong>不知道</strong> IP 多播组包含的成员数，<strong>也不知道</strong>这些成员都分布在哪些网络上。</li>
<li>IGMP 协议是让连接在<strong>本地局域网</strong>上的多播路由器知道本局域网上是否有主机（严格讲，是主机上的某个进程）参加或退出了某个多播组。 </li>
</ul>
<h3 id="多播路由选择协议比单播路由选择协议复杂的多"><a href="#多播路由选择协议比单播路由选择协议复杂的多" class="headerlink" title="多播路由选择协议比单播路由选择协议复杂的多"></a>多播路由选择协议比单播路由选择协议复杂的多</h3><ul>
<li>多播转发必须<strong>动态地</strong>适应多播组成员的变化（这时网络拓扑并未发生变化）。请注意，单播路由选择通常是在网络拓扑发生变化时才需要更新路由。</li>
<li>多播路由器在转发多播数据报时，不能仅仅根据多播数据报中的目的地址，而是还要考虑这个多播数据报从什么地方来和要到什么地方去。 </li>
<li>多播数据报可以由没有加入多播组的主机发出，也可以通过没有组成员接入的网络。 </li>
</ul>
<h3 id="IGMP是整个网际协议IP的一个组成部分"><a href="#IGMP是整个网际协议IP的一个组成部分" class="headerlink" title="IGMP是整个网际协议IP的一个组成部分"></a>IGMP是整个网际协议IP的一个组成部分</h3><ul>
<li>和 ICMP 相似，IGMP 使用 IP 数据报传递其报文（即 IGMP 报文加上 IP 首部构成 IP 数据报），但它也向 IP 提供服务。</li>
<li>因此，我们不把 IGMP 看成是一个单独的协议，而是属于整个网际协议 IP 的一个组成部分。 </li>
</ul>
<h3 id="IGMP可分为两个阶段"><a href="#IGMP可分为两个阶段" class="headerlink" title="IGMP可分为两个阶段"></a>IGMP可分为两个阶段</h3><ul>
<li>第一阶段：当某个主机加入新的多播组时，该主机应向多播组的多播地址发送IGMP 报文，声明自己要成为该组的成员。本地的多播路由器收到 IGMP 报文后，将组成员关系转发给因特网上的其他多播路由器。</li>
<li>第二阶段：因为组成员关系是<strong>动态</strong>的，因此本地多播路由器要<strong>周期性地探询</strong>本地局域网上的主机，以便知道这些主机是否还继续是组的成员。</li>
</ul>
<p>只要对某个组有一个主机响应，那么多播路由器就认为这个组是活跃的。<br>但一个组在经过几次的探询后仍然没有一个主机响应，则不再将该组的成员关系转发给其他的多播路由器。</p>
<h3 id="IGMP采用的一些具体措施"><a href="#IGMP采用的一些具体措施" class="headerlink" title="IGMP采用的一些具体措施"></a>IGMP采用的一些具体措施</h3><ul>
<li>在<strong>主机</strong>和<strong>多播路由器</strong>之间的所有通信都是使用 IP 多播。</li>
<li>多播路由器在探询组成员关系时，只需要对所有的组发送一个请求信息的询问报文，而不需要对每一个组发送一个询问报文。默认的询问速率是每 125 秒发送一次。</li>
<li>当同一个网络上连接有几个多播路由器时，它们能够迅速和有效地选择其中的一个来探询主机的成员关系。</li>
<li>在 IGMP 的询问报文中有一个数值 N，它指明一个最长响应时间（默认值为 10秒）。当收到询问时，主机在 0 到 N 之间随机选择发送响应所需经过的时延。对应于最小时延的响应最先发送。</li>
<li>同一个组内的每一个主机都要监听响应，只要有本组的其他主机先发送了响应，自己就可以不再发送响应了。 </li>
</ul>
<h3 id="多播路由选择"><a href="#多播路由选择" class="headerlink" title="多播路由选择"></a>多播路由选择</h3><ul>
<li>多播路由选择协议尚未标准化。</li>
<li>一个多播组中的成员是动态变化的，随时会有主机加入或离开这个多播组。</li>
<li>多播路由选择实际上就是要找出以源主机为根结点的多播转发树。</li>
<li>在多播转发树上的路由器不会收到重复的多播数据报。</li>
<li>对不同的多播组对应于不同的多播转发树。同一个多播组，对不同的源点也会有不同的多播转发树。</li>
</ul>
<h3 id="转发多播数据报使用的方法"><a href="#转发多播数据报使用的方法" class="headerlink" title="转发多播数据报使用的方法"></a>转发多播数据报使用的方法</h3><h4 id="洪泛与剪除"><a href="#洪泛与剪除" class="headerlink" title="洪泛与剪除"></a>洪泛与剪除</h4><p>这种方法适合于<strong>较小的多播组</strong>，而所有的组成员接入的局域网也是<strong>相邻接</strong>的。一开始，路由器转发多播数据报使用洪泛的方法（这就是广播）。为了避免兜圈子，采用了叫做<strong>反向路径广播</strong> RPB (Reverse Path Broadcasting)的策略。 </p>
<h5 id="RPB的要点"><a href="#RPB的要点" class="headerlink" title="RPB的要点"></a>RPB的要点</h5><ul>
<li>路由器收到多播数据报时，先检查是否从源点经最短路径传送来的。</li>
<li>若是，就向所有其他方向转发刚才收到的多播数据报（但进入的方向除外），否则就丢弃而不转发。</li>
<li><p>如果存在几条同样长度的最短路径），那么只能选择一条最短路径，选择的准则就是看这几条最短路径中的相邻路由器谁的 IP 地址最小。 </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-90bb5a28035ecd25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="反向路径广播RPB和剪除.png"></p>
</li>
</ul>
<p>上图粗线为<strong>多播转发树</strong></p>
<h3 id="隧道技术（tunneling）"><a href="#隧道技术（tunneling）" class="headerlink" title="隧道技术（tunneling）"></a>隧道技术（tunneling）</h3><p>隧道技术适用于多播组的位置在地理上很分散的情况，图中网1和网2都支持多播，但是R1R2不支持，因而R1R2不能按多播地址转发数据报。为此R1对数据报进行再次封装，即加上普通数据报首部，使其成为向单一站发送的单播数据报，然后通过隧道从R1发送到R2，单播数据报到达R2时，剥去首部使其恢复为多播数据报，继续向多个目的站转发<br><img src="http://upload-images.jianshu.io/upload_images/1213532-5a6ad74ba113dc0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="隧道技术.png"></p>
<h3 id="基于核心的发现技术"><a href="#基于核心的发现技术" class="headerlink" title="基于核心的发现技术"></a>基于核心的发现技术</h3><ul>
<li>这种方法对于多播组的大小在较大范围内变化时都适合。</li>
<li>这种方法是对每一个多播组 G 指定一个<strong>核心</strong>(core)路由器，给出它的 IP 单播地址。</li>
<li>核心路由器按照前面讲过的方法创建出对应于多播组 G 的转发树。 </li>
</ul>
<h3 id="几种多播路由选择协议"><a href="#几种多播路由选择协议" class="headerlink" title="几种多播路由选择协议"></a>几种多播路由选择协议</h3><p>距离向量多播路由选择协议 DVMRP (Distance Vector Multicast Routing Protocol)</p>
<ul>
<li>基于核心的转发树 CBT (Core Based Tree) </li>
<li>开放最短通路优先的多播扩展 MOSPF(Multicast Extensions to OSPF) </li>
<li>协议无关多播-稀疏方式 PIM-SM(Protocol Independent Multicast-Sparse Mode) </li>
<li>协议无关多播-密集方式 PIM-DM(Protocol Independent Multicast-Dense Mode)  </li>
</ul>
<h2 id="虚拟专用网VPN和网络地址转换NAT"><a href="#虚拟专用网VPN和网络地址转换NAT" class="headerlink" title="虚拟专用网VPN和网络地址转换NAT"></a>虚拟专用网VPN和网络地址转换NAT</h2><h3 id="虚拟专用网VPN"><a href="#虚拟专用网VPN" class="headerlink" title="虚拟专用网VPN"></a>虚拟专用网VPN</h3><ul>
<li><strong>本地地址</strong>——仅在机构内部使用的 IP 地址，可以由本机构自行分配，而不需要向因特网的管理机构申请。</li>
<li><strong>全球地址</strong>——全球唯一的IP地址，必须向因特网的管理机构申请。 </li>
</ul>
<h3 id="RFC-1918指明了一些专用地址（private-address）"><a href="#RFC-1918指明了一些专用地址（private-address）" class="headerlink" title="RFC 1918指明了一些专用地址（private address）"></a>RFC 1918指明了一些专用地址（private address）</h3><ul>
<li>10.0.0.0 到 10.255.255.255</li>
<li>172.16.0.0 到 172.31.255.255</li>
<li>192.168.0.0 到 192.168.255.255</li>
</ul>
<p>这些地址只能用于一个机构的<strong>内部通信</strong>，而不能用于和因特网上的主机通信。<br>专用地址只能用作本地地址而不能用作全球地址。在因特网中的<strong>所有路由器</strong>对目的地址是专用地址的数据报一律<strong>不进行转发</strong>。 </p>
<p>有时一个很大的机构有许多部门在相距很远的一些地点，而每一个地点有自己的专用网，假定这些分布在不同地点的专用网要经常通信，这时有两种方法</p>
<ul>
<li>租用电信公司的通信线路，但是租金太贵</li>
<li>利用公用因特网作为本机构各专用网之间的通信载体，这样的专用网又称为<strong>虚拟专用网（Virtual Private Network）</strong></li>
</ul>
<p>如果专用网不同网点之间的通信必须经过公用的因特网，但又有保密的要求，那么<strong>所有通过因特网传输的数据都要进行加密</strong>，虚拟表示好像是但实际并不是，因为现在<strong>并没有使用专线</strong>而是通过<strong>公用的因特网</strong>来连接分散在各地的本地网络。VPN只是<strong>效果上</strong>和真正的专用网一样，一个机构要构件自己的VPN就必须为它的每一个场所购买专用的硬件和软件，并进行配置，使每一个场所的VPN系统都知道其他场所的地址。</p>
<h3 id="隧道技术实现虚拟专用网"><a href="#隧道技术实现虚拟专用网" class="headerlink" title="隧道技术实现虚拟专用网"></a>隧道技术实现虚拟专用网</h3><p><img src="http://upload-images.jianshu.io/upload_images/1213532-f7b5290dcd48856d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="隧道技术实现虚拟专用网01.png"><br>R1R2这两个路由器和因特网的接口必须是合法的<strong>全球IP地址</strong>，和专用网内部的接口是<strong>本地网的本地地址</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1213532-0861380928829908.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="隧道技术实现虚拟专用网02.png"></p>
<h3 id="内联网-intranet-和外联网-extranet（都是基于-TCP-IP-协议）"><a href="#内联网-intranet-和外联网-extranet（都是基于-TCP-IP-协议）" class="headerlink" title="内联网 intranet 和外联网 extranet（都是基于 TCP/IP 协议）"></a>内联网 intranet 和外联网 extranet（都是基于 TCP/IP 协议）</h3><ul>
<li>由部门 A 和 B 的内部网络所构成的虚拟专用网 VPN 又称为<strong>内联网</strong>(intranet)，表示部门 A 和 B 都是在同一个机构的内部。</li>
<li>一个机构和某些<strong>外部机构</strong>共同建立的虚拟专用网 VPN 又称为<strong>外联网</strong>(extranet)。  </li>
</ul>
<h3 id="远程接入VPN（remote-access-VPN）"><a href="#远程接入VPN（remote-access-VPN）" class="headerlink" title="远程接入VPN（remote access VPN）"></a>远程接入VPN（remote access VPN）</h3><ul>
<li>有的公司可能没有分布在不同场所的部门，但有很多流动员工在外地工作。公司需要和他们保持联系，远程接入 VPN 可满足这种需求。</li>
<li>在外地工作的员工拨号接入因特网，而驻留在员工 PC 机中的 VPN 软件可在员工的 PC 机和公司的主机之间建立 VPN 隧道，因而外地员工与公司通信的内容是保密的，员工们感到好像就是使用公司内部的本地网络。 </li>
</ul>
<h2 id="网络地址转换NAT（network-address-translation）"><a href="#网络地址转换NAT（network-address-translation）" class="headerlink" title="网络地址转换NAT（network address translation）"></a>网络地址转换NAT（network address translation）</h2><p>在专用网内部的一些主机已经分配到了本地IP地址，但还想和因特网上面的主机通信，就要采用NAT技术。</p>
<ul>
<li>网络地址转换 NAT  方法于1994年提出。</li>
<li>需要在专用网连接到因特网的路由器上安装 NAT 软件。装有 NAT 软件的路由器叫做 NAT路由器，它至少有一个有效的外部全球地址 IP。</li>
<li>所有使用本地地址的主机在和外界通信时都要在 NAT 路由器上将其本地地址转换成 IP 才能和因特网连接。  </li>
</ul>
<h3 id="网络地址转换过程"><a href="#网络地址转换过程" class="headerlink" title="网络地址转换过程"></a>网络地址转换过程</h3><ul>
<li>内部主机 X 用本地地址 IPX 和因特网上主机 Y 通信所发送的数据报必须经过 NAT 路由器。</li>
<li>NAT 路由器将数据报的源地址 IPX 转换成全球地址 IPG，但目的地址 IPY 保持不变，然后发送到因特网。</li>
<li>NAT 路由器收到主机 Y 发回的数据报时，知道数据报中的源地址是 IPY 而目的地址是 IPG。</li>
<li>根据 NAT 转换表，NAT 路由器将目的地址 IPG 转换为 IPX，转发给最终的内部主机 X。</li>
</ul>


                <hr>

                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2016/08/06/线程/" data-toggle="tooltip" data-placement="top" title="线程">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2016/08/06/死锁/" data-toggle="tooltip" data-placement="top" title="死锁">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

            </div>
    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#计算机网络" title="计算机网络">计算机网络</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>

        </div>
    </div>
</article>




<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "hexo-theme-huxblog";
    var disqus_identifier = "http://github.com/srtianxia/srtianxia.github.io/2016/08/06/网络层/";
    var disqus_url = "http://github.com/srtianxia/srtianxia.github.io/2016/08/06/网络层/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("http://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/srtianxia">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/srtianxia">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/srtianxia">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Srtianxia&#39;s Blog 2016 
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    Ported by <a href="http://blog.kaijun.rocks">Kaijun</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://github.com/srtianxia/srtianxia.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("http://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->


<!-- Side Catalog -->





<!-- Image to hack wechat -->
<img src="http://github.com/srtianxia/srtianxia.github.io/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
